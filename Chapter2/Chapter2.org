#+TITLE: SICP Solutions: Chapter2
#+AUTHOR: Orab
#+STARTUP: indent
#+TODO: TODO TOVERIFY | VERIFIED

* Exercise2.1
对于一个分数而言, 只有当分子分母同时取负时值不变, 所以如果要保证分母始终为正值,
只需要在分母为负时对分子分母同时取负即可.

=make-rat= 的更好版本定义如下:
#+Name: make-rat.scm
#+BEGIN_SRC scheme
  (define (make-rat numer denom)
    (let ((g (gcd numer denom)))
        (if (< (/ denom g) 0)
            (cons (- (/ numer g)) (- (/ denom g)))
            (cons (/ numer g) (/ denom g)))))

#+END_SRC

* Exercise2.2
平面上线段表示的定义实现如下:
#+Name: segment.scm
#+BEGIN_SRC scheme
  (define (make-segment start end)
    (cons start end))
  (define (start-segment segment)
    (car segment))
  (define (end-segment segment)
    (cdr segment))

  (define (make-point x y)
    (cons x y))
  (define (x-point point)
    (car point))
  (define (y-point point)
    (cdr point))

  (define (print-point point)
    (newline)
    (display "(")
    (display (x-point point))
    (display ",")
    (display (y-point point))
    (display ")"))

  (define (midpoint-segment segment)
    (make-point (/ (+ (x-point (start-segment segment))
                      (x-point (end-segment segment)))
                   2)
                (/ (+ (y-point (start-segment segment))
                      (y-point (end-segment segment)))
                   2)))

#+END_SRC
验证输出结果为:
#+Name: Output
#+BEGIN_SRC shell
  scheme@(guile-user)> (define x (make-point 2 9))
  scheme@(guile-user)> (define y (make-point 4 8))
  scheme@(guile-user)> (define seg (make-segment x y))
  scheme@(guile-user)> (define mp (midpoint-segment seg))
  scheme@(guile-user)> (print-point mp)

  (3,17/2)

#+END_SRC

* TODO Exercise2.3
TODO: 平面矩形是否需要确定位置及旋转角度等信息, 如果需要该怎样实现?

* Exercise2.4
利用代换模型, 将 =car= 过程依次展开的结果为:
#+Name: verify
#+BEGIN_SRC scheme
  (car (cons x y))
  ((cons x y) (lambda (p q) p))
  ((lambda (m) (m x y)) (lambda (p q) p))
  ((lambda (p q) p) x y)
  x

#+END_SRC

对应的 =cdr= 的定义为:
#+Name: cdr.scm
#+BEGIN_SRC scheme
  (define (cdr z)
    (z (lambda (p q) q)))
#+END_SRC

* Exercise2.5
由于2的幂和3的幂不存在大于1的公约数, 所以分别找出可以整除的2的最大次幂和可以整
除的3的最大次幂的结果就可以确定a和b的值.

过程定义如下:
#+Name: cons-power.scm
#+BEGIN_SRC scheme
  (define (power x n)
    (if (= n 1)
        x
        (* x (power x (- n 1)))))

  (define (cons a b)
    (* (power 2 a)
       (power 3 b)))
  (define (car z)
    (if (= 0 (remainder z 2))
        (+ 1 (car (/ z 2)))
        0))
  (define (cdr z)
    (if (= 0 (remainder z 3))
        (+ 1 (cdr (/ z 3)))
        0))
#+END_SRC

* Exercise2.6
通过代换Church计数的 =zero= 和 =add-1= 到 =(add-1 zero)= 中, 结果如下:
#+Name: one.scm
#+BEGIN_SRC scheme
  (add-1 zero)
  (lambda (f) (lambda (x) (f ((zero f) x))))
  (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x))))
  (lambda (f) (lambda (x) (f ((lambda (x) x) x))))
  (lambda (f) (lambda (x) (f x)))
#+END_SRC
即 =one= 的定义式为 =(lambda (f) (lambda (x) (f x)))=.

再将 =one= 和 =add-1= 代入到 =(add-1 one)= 中, 结果如下:
#+Name: two.scm
#+BEGIN_SRC scheme
  (add-1 two)
  (lambda (f) (lambda (x) (f ((one f) x))))
  (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f x))) f) x))))
  (lambda (f) (lambda (x) (f ((lambda (x) (f x)) x))))
  (lambda (f) (lambda (x) (f (f x))))
#+END_SRC
即 =two= 的定义式为 =(lambda (f) (lambda (x) (f (f x))))=.

经过上面的代换可以看出 =add-1= 的过程实际上相当于在原来的过程中增加了一个 =f=
函数的迭代调用, 而加法的定义可以看做是 =add-n= 的过程, 即要在原来的过程中增加n
个 =f= 函数的迭代调用, 等于用Church计数时数n中 =f= 函数迭代调用的次数.

因此加法过程的一个直接定义为:
#+Name: add.scm
#+BEGIN_SRC scheme
  (define (+ a b)
    (lambda (f) (lambda (x) ((a f) ((b f) x)))))
#+END_SRC

* Exercise2.7
区间构造的完整基础定义如下:
#+Name: interval.scm
#+BEGIN_SRC scheme
  (define (make-interval a b) (cons a b))
  (define (upper-bound interval)
    (if (> (car interval) (cdr interval))
        (car interval)
        (cdr interval)))
  (define (lower-bound interval)
    (if (< (car interval) (cdr interval))
        (car interval)
        (cdr interval)))

#+END_SRC

* Exercise2.8
对于两个区间的减法来说, 最大值为减数的上界减去被减数的下界, 最小值为减数的下界
减去被减数的上界. 具体定义如下:
#+Name sub-interval.scm
#+BEGIN_SRC scheme
  (define (sub-interval x y)
    (make-interval (- (upper-bound x) (lower-bound y))
                   (- (lower-bound x) (upper-bound y))))
#+END_SRC

* Exercise2.9
我们可以通过一般化的推导来证明题中的结论:

假设两个区间分别为 =(a1, b1)=, =(a2, b2)=, 则它们的和为 =(a1 + a2, b1 + b2)=,两
个区间的宽度分别为 =b1 - a1=, =b2 - a2=, 而它们和的宽度为 =(b1 + b2) - (a1 +
a2) = (b1 - a1) + (b2 - a2)=, 即两个区间的和的宽度等于两个区间宽度的和. 减法的过
程同样如此, 上述两个区间的差为 =(a1 - b2, b1 - a2)=, 它们差的宽度为 =(b1 -
a2) - (a1 - b2) = (b1 - a1) - (b2 - a2)=, 两个区间的差的宽度等于两个区间宽度的差.

对于乘和除而言并不满足这样的关系, 例如区间 =(1, 4)= 和 =(3, 9)= 的区间宽度分别
为 =3= 和 =6=, 它们的乘积为 =(3, 36)=, 乘积宽度为 =33=, 而宽度的乘积为 =18=; 它
们的商为 =(1/9, 4/3)=, 商宽度为 =10/9=, 而宽度的商为 =1/2=.

* Exercise2.10
修正 =div-interval= 的过程为:
#+Name: div-interval.scm
#+BEGIN_SRC scheme
  (define (div-interval x y)
    (if (>= 0 (* (upper-bound y) (lower-bound y)))
        (error "The interval contains zeros in divider")
        (mul-interval x
                      (make-interval (/ 1.0 (upper-bound y))
                                     (/ 1.0 (lower-bound y))))))
#+END_SRC

* TODO Exercise2.11
重写 =mul-interval= 的过程如下:
#+Name: mul-interval.scm
#+BEGIN_SRC scheme
#+END_SRC

* Exercise2.12
=make-center-percent= 的过程定义如下:
#+Name: center-percent.scm
#+BEGIN_SRC scheme
  (define (make-center-percent c p)
    (make-interval (- c (* c p))
                   (+ c (* c p))))
  (define (center i)
    (/ (+ (lower-bound i) (upper-bound i)) 2))
  (define (percent i)
    (/ (/ (- (upper-bound i) (lower-bound i)) 2)
       (/ (+ (upper-bound i) (lower-bound i)) 2)))
#+END_SRC

* Exercise2.13
设两个区间分别为 =(x - ax, x + ax)=, =(y - by, y + by)=, 它们的乘积宽度为
=(xy + axy + bxy + abxy) - (xy - axy - bxy + abxy) = 2(a + b)xy=, 当百分比很小时,
乘积本身可看做 =(xy - (a + b)xy, xy + (a + b)xy)=, 所以两个被乘区间的百分误差可
看做各自百分误差之和.

* TOVERIFY Exercise2.14
1. 通过程序验证, 得到的输出如下:
   #+Name: Output
   #+BEGIN_SRC
     scheme@(guile-user)> (define r1 (make-interval 2 4))
     scheme@(guile-user)> (define r2 (make-interval 3 8))
     scheme@(guile-user)> (par1 r1 r2)
     $1 = (0.5 . 6.4)
     scheme@(guile-user)> (par2 r1 r2)
     $2 = (1.2000000000000002 . 2.6666666666666665)

   #+END_SRC
   可以看到两种方式所得到的结果完全不同.

2. 按照中心-百分比形式进行除法检验的输出为:
   #+Name: Output
   #+BEGIN_SRC
     scheme@(guile-user)> (define A (make-interval 60 62))
     scheme@(guile-user)> (define B (make-interval 30 33))
     scheme@(guile-user)> (div-interval A A)
     $1 = (0.967741935483871 . 1.0333333333333332)
     scheme@(guile-user)> (div-interval A B)
     $2 = (1.8181818181818183 . 2.0666666666666664)
     scheme@(guile-user)> (define A (make-center-percent 60 0.01))
     scheme@(guile-user)> (define B (make-center-percent 30 0.02))
     scheme@(guile-user)> (define r1 (div-interval A A))
     scheme@(guile-user)> (center r1)
     $3 = 1.000200020002
     scheme@(guile-user)> (percent r1)
     $4 = 0.019998000199980024scheme
     @(guile-user)> (define r2 (div-interval A B))
     scheme@(guile-user)> (center r2)
     $5 = 2.001200480192077
     scheme@(guile-user)> (percent r2)
     $6 = 0.02999400119976012

   #+END_SRC
   可以看出两个相同区间作除法并没有得到理论上的标准单位元. 商的误差百分比大致相
   当于被除数和除数的误差百分比之和, 即所做运算使误差区间增大.

* TODO Exercise2.15
* TODO Exercise2.16
* Exercise2.17
过程 =last-pair= 的定义如下:
#+Name: last-pair.scm
#+BEGIN_SRC scheme
  (define (last-pair list)
    (if (null? (cdr list))
        list
        (last-pair (cdr list))))
#+END_SRC

* Exercise2.18
过程 =reverse= 的定义如下:
#+Name reverse.scm
#+BEGIN_SRC scheme
  (define (reverse list)
    (if (null? list)
        '()
        (append (reverse (cdr list))
              (cons (car list) '()))))
#+END_SRC

* Exercise2.19
兑换零钱方式计数的改进版本定义如下:
#+Name: cc.scm
#+BEGIN_SRC scheme
  (define us-coins (list 50 25 10 5 1))
  (define uk-coins (list 100 50 20 10 5 2 1 0.5))

  (define (cc amount coin-values)
    (cond ((= amount 0) 1)
          ((or (< amount 0) (no-more? coin-values)) 0)
          (else
           (+ (cc amount
                  (except-first-denomination coin-values))
              (cc (- amount
                     (first-denomination coin-values))
                  coin-values)))))

  (define (no-more? coin-values)
    (null? coin-values))

  (define (except-first-denomination coin-values)
    (cdr coin-values))

  (define (first-denomination coin-values)
    (car coin-values))
#+END_SRC
表 =coin-values= 的排列顺序不会影响cc给出的答案, 因为
=except-first-denomination= 和 =first-denomination= 的过程包含了所有可能的情况,
即任何一种可能的情况要么出现在第一种情况中, 要么出现在第二种情况中, 而与顺序无关.

* Exercise2.20
过程 =same-parity= 的定义如下:
#+Name: same-parity.scm
#+BEGIN_SRC scheme
  (define (same-parity x . list)
    (let ((same? (if (even? x)
                     even?
                     odd?)))
      (define (parity list)
        (cond ((null? list) '())
              ((same? (car list))
               (cons (car list) (parity (cdr list))))
              (else (parity (cdr list)))))
      (cons x (parity list))))
#+END_SRC

* Exercise2.21
过程 =square-list= 的两个定义的补全如下:
#+Name: square-list.scm
#+BEGIN_SRC scheme
  (define (square-list items)
    (if (null? items)
        '()
        (cons (square (car items))
              (square-list (cdr items)))))

  (define (square-list items)
    (map (lambda (x) (square x))
         items))
#+END_SRC

* Exercise2.22
1. 按第一种方式产生出的结果中, 因为items中先被取出(car)的元素会先被加入结果的表
   中, 这样原表中的元素在新表中会在与之对称的位置, 即元素的顺序正好相反.
2. 按照第二种方式, 说得结果中每个cons的第二个元素都指向一个实际值, 与表定义所要
   求的正好相反.

* Exercise2.23
过程 =for-each= 的一个实现如下:
#+Name: for-each.scm
#+BEGIN_SRC scheme
  (define (for-each f items)
    (cond ((null? items) #t)
          (else
           (f (car items))
           (for-each f (cdr items)))))
#+END_SRC

* TODO Exercise2.24
解释器打印的结果为 =(1 (2 (3 4)))=.
TODO: 图形化显示对应的盒状指针结构.

* Exercise2.25
从下面各表中取出7的 =car= 和 =cdr= 的组合为:
#+Name: Solutions
#+BEGIN_SRC scheme
  ;; (1 3 (5 7) 9)
  (define x '(1 3 (5 7) 9))
  (car (cdr (car (cdr (cdr x)))))

  ;; ((7))
  (define y '((7)))
  (car (car y))

  ;; (1 (2 (3 (4 (5 (6 7))))))
  (define z '(1 (2 (3 (4 (5 (6 7)))))))
  (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr z))))))))))))
#+END_SRC

* Exercise2.26
各个表达式的打印结果如下:
#+Name: Solutions
#+BEGIN_SRC scheme
  ;; x: (1 2 3) y: (4 5 6)

  ;; (append x y)
  (1 2 3 4 5 6)

  ;; (cons x y)
  ((1 2 3) 4 5 6)

  ;; (list x y)
  ((1 2 3) (4 5 6))
#+END_SRC

* Exercise2.27
过程 =deep-reverse= 的定义如下:
#+Name: deep-reverse.scm
#+BEGIN_SRC scheme
  (define (deep-reverse tree)
    (cond ((null? tree) '())
          ((not (pair? tree)) tree)
          (else (append (deep-reverse (cdr tree))
                        (cons (deep-reverse (car tree))
                              '())))))
#+END_SRC

* Exercise2.28
过程 =fringe= 的定义如下:
#+Name: fringe.scm
#+BEGIN_SRC scheme
  (define (fringe tree)
    (cond ((null? tree) '())
          ((not (pair? (car tree)))
           (cons (car tree) (fringe (cdr tree))))
          (else (append (fringe (car tree))
                        (fringe (cdr tree))))))
#+END_SRC

* Exercise2.29
1. =branch= 的一些简单操作定义如下:
   #+Name: branch.scm
   #+BEGIN_SRC scheme
     (define (make-mobile left right)
       (list left right))

     (define (make-branch length structure)
       (list length structure))

     (define (left-branch mobile)
       (car mobile))

     (define (right-branch mobile)
       (car (cdr mobile)))

     (define (branch-length branch)
       (car branch))

     (define (branch-structure branch)
       (car (cdr branch)))
   #+END_SRC
2. 过程 =total-weight= 的定义如下:
   #+Name: total-weight.scm
   #+BEGIN_SRC scheme
     (define (total-weight mobile)
       (cond ((null? mobile) 0)
             ((not (pair? mobile)) mobile)
             (else
              (+ (total-weight
                  (branch-structure (left-branch mobile)))
                 (total-weight
                  (branch-structure (right-branch mobile)))))))
   #+END_SRC
3. 检查一个二叉活动体是否平衡的过程 =balance?= 的定义如下:
   #+Name: balance?.scm
   #+BEGIN_SRC scheme
     (define (balance? mobile)
       (if (or (null? mobile) (not (pair? mobile)))
           #t
           (and (= (* (branch-length (left-branch mobile))
                      (total-weight
                       (branch-structure (left-branch mobile))))
                   (* (branch-length (right-branch mobile))
                      (total-weight
                       (branch-structure (right-branch mobile)))))
                (balance? (branch-structure (left-branch mobile)))
                (balance? (branch-structure (right-branch mobile))))))
   #+END_SRC
4. 如果改变活动体的构造方式, 要保持程序仍旧可用, 只需修改对应的选择函数即可:
   #+Name: branch-modified.scm
   #+BEGIN_SRC scheme
     (define (make-mobile left right)
       (cons left right))

     (define (make-branch length structure)
       (cons length structure))

     (define (left-branch mobile)
       (car mobile))

     (define (right-branch mobile)
       (cdr mobile))

     (define (branch-length branch)
       (car branch))

     (define (branch-structure branch)
       (cdr branch))
   #+END_SRC

* Exercise2.30
使用递归定义 =square-tree= 的过程如下:
#+Name: square-tree.scm
#+BEGIN_SRC scheme
  (define (square-tree tree)
    (cond ((null? tree) '())
          ((not (pair? tree)) (square tree))
          (else (cons (square-tree (car tree))
                      (square-tree (cdr tree))))))
#+END_SRC
使用 =map= 定义 =square-tree= 的过程如下:
#+Name: square-tree.scm
#+BEGIN_SRC scheme
  (define (square-tree tree)
    (map (lambda (subtree)
           (if (pair? subtree)
               (square-tree subtree)
               (square subtree)))
         tree))
#+END_SRC

* Exercise2.31
利用 =map= 做进一步的抽象过程 =tree-map=, 过程定义如下:
#+Name: tree-map.scm
#+BEGIN_SRC scheme
  (define (tree-map func tree)
    (map (lambda (subtree)
           (if (pair? subtree)
               (tree-map func subtree)
               (func subtree)))
         tree))
#+END_SRC

* Exercise2.32
过程 =subsets= 的完整定义如下:
#+Name: subsets.scm
#+BEGIN_SRC scheme
  (define (subsets s)
    (if (null? s)
        (list '())
        (let ((rest (subsets (cdr s))))
          (append rest (map (lambda (x) (cons (car s) x)) rest)))))
#+END_SRC
一个集合的所有子集可以看作是包含第一个元素的子集和不包含第一个元素的子集的总和.

* Exercise2.33
完整的表达式如下:
#+Name: Solutions
#+BEGIN_SRC scheme
  ;; 1)
  (define (map p sequence)
    (accumulate (lambda (x y) (cons (p x) y)) '() sequence))

  ;; 2)
  (define (append seq1 seq2)
    (accumulate cons seq2 seq1))

  ;; 3)
  (define (length sequence)
    (accumulate (lambda (x y) (+ 1 y)) 0 sequence))
#+END_SRC

* Exercise2.34
利用Horner规则求多项式值的完整过程定义如下:
#+Name: horner-eval.scm
#+BEGIN_SRC scheme
  (define (horner-eval x coefficient-sequence)
    (accumulate (lambda (this-coeff higher-terms)
                  (+ this-coeff (* x higher-terms)))
                0
                coefficient-sequence))
#+END_SRC

* Exercise2.35
用累积的形式重新定义 =count-leaves= 的过程如下:
#+Name: count-leaves.scm
#+BEGIN_SRC scheme
  (define (count-leaves t)
    (accumulate + 0
                (map (lambda (x) 1) (fringe t))))
#+END_SRC

* Exercise2.36
完整的 =accumulate-n= 定义如下:
#+Name: accumulate-n.scm
#+BEGIN_SRC scheme
  (define (accumulate-n op init seqs)
    (if (null? (car seqs))
        '()
        (cons (accumulate op init (map car seqs))
              (accumulate-n op init (map cdr seqs)))))
#+END_SRC

* Exercise2.37
矩阵运算基本操作的完整定义如下:
#+Name: matrix-op.scm
#+BEGIN_SRC scheme
  (define (dot-product v w)
    (accumulate + 0 (map * v w)))

  (define (matrix-*-vector m v)
    (map (lambda (x) (dot-product x v)) m))

  (define (transpose mat)
    (accumulate-n cons '() mat))

  (define (matrix-*-matrix m n)
    (let ((cols (transpose n)))
      (map (lambda (x) (matrix-*-vector cols x)) m)))
#+END_SRC

* Exercise2.38
下列各式的值依次为:
#+Name: Solutions
#+BEGIN_SRC scheme
  ;; (fold-right / 1 (list 1 2 3))
  3/2

  ;; (fold-left / 1 (list 1 2 3))
  1/6

  ;; (fold-right list nil (list 1 2 3))
  (1 (2 (3 ())))

  ;; (fold-left list nil (list 1 2 3))
  (((() 1) 2) 3)
#+END_SRC

* Exercise2.39
分别基于 =fold-right= 和 =fold-left= 定义 =reverse= 的过程如下:
#+Name: reverse.scm
#+BEGIN_SRC scheme
  (define (reverse sequence)
    (fold-right (lambda (x y) (append y (list x))) '() sequence))

  (define (reverse sequence)
    (fold-left (lambda (x y) (cons y x)) '() sequence))
#+END_SRC

* Exercise2.40
过程 =unique-pairs= 的定义如下:
#+Name: unique-pairs.scm
#+BEGIN_SRC scheme
  (define (unique-pairs n)
    (flatmap (lambda (i)
               (map (lambda (j) (list i j))
                    (enumerate-interval 1 (- i 1))))
             (enumerate-interval 1 n)))

  (define (enumerate-interval beg end)
    (cond ((> beg end) '())
          ((= beg end) (list end))
          (else (cons beg (enumerate-interval (+ beg 1) end)))))
#+END_SRC
用 =unique-pairs= 简化 =prime-sum-pairs= 的定义如下:
#+Name: prime-sum-pairs.scm
#+BEGIN_SRC scheme
  (define (prime-sum-pairs n)
    (map make-pair-sum
         (filter prime-sum? (unique-pairs n))))

  (define (prime-sum? pair)
    (prime? (+ car pair) (cadr pair)))

  (define (make-pair-sum pair)
    (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
#+END_SRC

* Exercise2.41
过程 =fixed-sum-tuples= 的定义如下:
#+Name: fixed-sum-tuples.scm
#+BEGIN_SRC scheme
  (define (fixed-sum-tuples n s)
    (filter (lambda (t)
              (= s (+ (car t) (cadr t) (caddr t))))
            (flatmap (lambda (i)
                       (flatmap (lambda (j)
                                  (map (lambda (k) (list i j k))
                                       (remove j
                                               (remove i (enumerate-interval 1 n)))))
                                (remove i (enumerate-interval 1 n))))
                     (enumerate-interval 1 n))))

#+END_SRC

* Exercise2.42
解决八皇后问题的完整过程定义如下:
#+Name: queens.scm
#+BEGIN_SRC scheme
  (define (queens board-size)
    (define (queen-cols k)
      (if (= k 0)
          (list empty-board)
          (filter
           (lambda (positions) (safe? k positions))
           (flatmap
            (lambda (rest-of-queens)
              (map (lambda (new-row)
                     (adjoin-position new-row k rest-of-queens))
                   (enumerate-interval 1 board-size)))
            (queen-cols (- k 1))))))
    (queen-cols board-size))

  (define (adjoin-position new-row k rest-queens)
    (cons new-row rest-queens))

  (define empty-board '())

  (define (safe? k positions)
    (define (iter cur i rest)
      (if (= i k)
          #t
          (and (not (= cur (car rest)))
               (not (= (- cur i) (car rest)))
               (not (= (+ cur i) (car rest)))
               (iter cur (+ i 1) (cdr rest)))))
    (iter (car positions) 1 (cdr positions)))
#+END_SRC

* Exercise2.43
假设执行一次 =adjoin-position= 的时间为单位时间, 当我们采用Exercise2.42中的过程
时, 有 =T(n) = T(n - 1) + a(n - 1) * k=, 其中 =T(n)= 表示 =k = n= 的运行时间,
=a(n)= 表示 =(queen-cols n)= 的长度. 当交换嵌套映射的顺序后, 运行时间 =T'(n) =
s * T'(n - 1) + a(n - 1) * k=, 其中 =s= 代表棋盘的大小, 当用后者去解决八皇后问题
时, 时间消耗大致为 =8^8 * T=.

* Exercise2.44
过程 =up-split= 定义如下:
#+Name: up-split.scm
#+BEGIN_SRC scheme
  (define (up-split painter n)
    (if (= n 0)
        painter
        (let ((smaller (up-split painter (- n 1))))
          (below painter (beside smaller smaller)))))
#+END_SRC

* Exercise2.45
过程 =split= 的定义如下:
#+Name: split.scm
#+BEGIN_SRC scheme
  (define (split p1 p2)
    (define (inner painter n)
      (if (= n 0)
          painter
          (let ((smaller (inner painter (- n 1))))
            (p1 (p2 smaller smaller))))))
#+END_SRC

* Exercise2.46
关于 =vect= 的一系列过程定义如下:
#+Name: vect.scm
#+BEGIN_SRC scheme
  (define (make-vect x y)
    (cons x y))

  (define (xcor-vect v)
    (car v))

  (define (ycor-vect v)
    (cdr v))

  (define (add-vect v1 v2)
    (make-vect (+ (xcor-vect v1) (xcor-vect v2))
               (+ (ycor-vect v1) (ycor-vect v2))))

  (define (sub-vect v1 v2)
    (make-vect (- (xcor-vect v1) (xcor-vect v2))
               (- (ycor-vect v1) (ycor-vect v2))))

  (define (scale-vect s v)
    (make-vect (* s (xcor-vect v))
               (* s (ycor-vect v))))
#+END_SRC

* Exercise2.47
为第一种 =make-frame= 实现选择函数为:
#+Name: make-frame.scm
#+BEGIN_SRC scheme
  (define (make-frame origin edge1 edge2)
    (list origin edge1 edge2))

  (define (origin-frame frame)
    (car frame))

  (define (edge1-frame frame)
    (cadr frame))

  (define (edge2-frame frame)
    (caddr frame))
#+END_SRC

第二种 =make-frame= 的选择函数实现为:
#+Name: make-frame.scm
#+BEGIN_SRC scheme
  (define (make-frame origin edge1 edge2)
    (cons origin (cons edge1 edge2)))

  (define (origin-frame frame)
    (car frame))

  (define (edge1-frame frame)
    (cadr frame))

  (define (edge2-frame frame)
    (cddr frame))
#+END_SRC

* Exercise2.48
基于 =vect= 定义 =segment= 的相关过程如下:
#+Name: segment.scm
#+BEGIN_SRC scheme
  (define (make-segment v1 v2)
    (cons v1 v2))

  (define (start-segment s)
    (car s))

  (define (end-segment s)
    (cdr s))
#+END_SRC

* TODO Exercise2.49
利用 =segments->painter= 分别定义如下的基本画家:
#+Name: painter.scm
#+BEGIN_SRC scheme
  ;; a) border-painter
  (define border-painter
    (segments->painter
     (list (make-segment (make-vect 0 0) (make-vect 0 1))
           (make-segment (make-vect 0 1) (make-vect 1 1))
           (make-segment (make-vect 1 1) (make-vect 1 0))
           (make-segment (make-vect 1 0) (make-vect 0 0)))))

  ;; b) X-painter
  (define X-painter
    (segments->painter
     (list (make-segment (make-vect 0 0) (make-vect 1 1))
           (make-segment (make-vect 1 0) (make-vect 0 1)))))

  ;; c) diamond-painter
  (define diamond-painter
    (segments->painter
     (list (make-segment (make-vect 0.5 0) (make-vect 1 0.5))
           (make-segment (make-vect 1 0.5) (make-vect 0.5 1))
           (make-segment (make-vect 0.5 1) (make-vect 0 0.5))
           (make-segment (make-vect 0 0.5) (make-vect 0.5 0)))))

  ;; d) wave
  (define wave (segments->painter wave-segments))
#+END_SRC

* Exercise2.50
过程 =flip-horiz= 的定义如下:
#+Name: flip-horiz.scm
#+BEGIN_SRC scheme
  (define (flip-horiz painter)
    (transform-painter painter
                       (make-vect 1.0 0.0)
                       (make-vect 1.0 1.0)
                       (make-vect 0.0 0.0)))

  ;; 180 degree rotate
  (define (rotate180 painter)
    (transform-painter painter
                       (make-vect 1.0 1.0)
                       (make-vect 0.0 1.0)
                       (make-vect 1.0 0.0)))

  ;; 270 degree rotate
  (define (rotate270 painter)
    (transform-painter painter
                       (make-vect 0.0 1.0)
                       (make-vect 0.0 0.0)
                       (make-vect 1.0 1.0)))
#+END_SRC

* TODO Exercise2.51
通过两种不同方式定义 =below= 的过程如下:
#+Name: below.scm
#+BEGIN_SRC scheme
  ;; 1
  (define (below painter1 painter2)
    (let ((split-point (make-vect 0.0 0.5)))
      (let ((paint-up
             (transform-painter painter1
                                (make-vect 0.0 0.0)
                                (make-vect 1.0 0.0)
                                split-point))
             (paint-down
              (transform-painter painter2
                               split-point
                               (make-vect 1.0 0.5)
                               (make-vect 0.0 1.0))))
        (lambda (frame)
          (paint-up frame)
          (paint-down frame)))))

  ;; 2 TODO
#+END_SRC

* TODO Exercise2.52

* Exercise2.53
下列各个表达式的值分别为:
#+Name: Solutions
#+BEGIN_SRC scheme
  ;; (list 'a 'b 'c)
  (a b c)

  ;; (list (list 'george))
  ((george))

  ;; (cdr '((x1 x2) (y1 y2)))
  ((y1 y2))

  ;; (cadr '((x1 x2) (y1 y2)))
  (y1 y2)

  ;; (pair? (car '(a short list)))
  #f

  ;; (memq 'red '((red shoes) (blue socks)))
  #f

  ;; (memq 'red '(red shoes blue socks))
  (red shoes blue socks)
#+END_SRC

* Exercise2.54
过程 =equal?= 的定义如下:
#+Name: equal?.scm
#+BEGIN_SRC scheme
  (define (equal? x y)
    (cond ((and (null? x) (null? y)) #t)
          ((and (pair? (car x)) (pair? (car y)))
           (and (equal? (car x) (car y))
                (equal? (cdr x) (cdr y))))
          (else (and (eq? (car x) (car y))
                (equal? (cdr x) (cdr y))))))
#+END_SRC

* Exercise2.55
表达式 =(car ''abracadabra)= 等价于 =(car (quote (quote abracadabra)))=, 即对列
表 =(quote abracadabra)= 做 =car= 操作, 因此返回结果为 =quote=.

* Exercise2.56
添加幂函数后的求导过程定义如下:
#+Name: exponentiation.scm
#+BEGIN_SRC scheme
  (define (make-exponentiation u n)
    (cond ((=number? n 0) 1)
          ((=number? n 1) u)
          (else (list '** n u))))

  (define (exponentiation? exp)
    (and (pair? exp) (eq? (car exp) '**)))

  (define (base exp)
    (cadr exp))

  (define (exponent exp)
    (caddr exp))

  (define (deriv exp var)
    (cond ((number? exp) 0)
          ((variable? exp)
           (if (same-variable? exp var) 1 0))
          ((sum? exp)
           (make-sum (deriv (addend exp) var)
                     (deriv (augend exp) var)))
          ((product? exp)
           (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
          ((exponentiation? exp)
           (make-product
            (make-product (exponent exp)
                          (make-exponentiation (base exp)
                                               (- (exponent exp) 1)))
            (deriv (base exp) var)))
          (else
           (error "unknown expression type -- DERIV" exp))))
           #+END_SRC

* Exercise2.57
经过改进的能处理任意项的和与乘积的求导程序定义如下:
#+Name: deriv-ex.scm
#+BEGIN_SRC scheme
  (define (make-sum . slist)
    (cons '+ slist))
  (define (make-product . plist)
    (cons '* plist))

  (define (addend s) (cadr s))

  (define (augend s)
    (if (= (length s) 3)
        (caddr s)
        (cons '+ (cddr s))))

  (define (multiplier p) (cadr p))

  (define (multiplicand p)
    (if (= (length p) 3)
        (caddr p)
        (cons '* (cddr p))))
#+END_SRC

* TODO Exercise2.58
1. 采用中缀表达式定义谓词, 选择函数和构造函数的过程定义如下:
   #+Name: infix-deriv.scm
   #+BEGIN_SRC scheme
     (define (make-sum a1 a2)
       (cond ((=number? a1 0) a2)
             ((=number? a2 0) a1)
             ((and (number? a1) (number? a2)) (+ a1 a2))
             (else (list a1 '+ a2))))
     (define (make-product m1 m2)
       (cond ((or (=number? m1 0) (=number? m2 0)) 0)
             ((=number? m1 1) m2)
             ((=number? m2 1) m1)
             ((and (number? m1) (number? m2)) (* m1 m2))
             (else (list m1 '* m2))))

     (define (sum? s)
       (and (pair? s) (eq? (cadr s) '+)))

     (define (product? p)
       (and (pair? p) (eq? (cadr p) '*)))

     (define (addend s) (car s))
     (define (augend s) (caddr s))

     (define (multiplier p) (car p))
     (define (multiplicand p) (caddr p))
   #+END_SRC
2. TODO 标准代数写法(中缀)的表示

* Exercise2.59
采用未排序的集合实现 =union-set= 的定义如下:
#+Name: union-set.scm
#+BEGIN_SRC scheme
  (define (union-set set1 set2)
    (cond ((not (element-of-set? (car set1) set2))
           (cons (car set1) set2))
          (else (union-set (cdr set1) set2))))
#+END_SRC

* Exercise2.60
允许重复的集合操作定义如下:
#+Name: multi-set.scm
#+BEGIN_SRC scheme
  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((equal? x (car set)) #t)
          (else (element-of-set? x (cdr set)))))

  (define (adjoin-set x set)
    (cons x set))

  (define (union-set set1 set2)
    (append set1 set2))

  (define (intersection-set set1 set2)
    (cond ((or (null? set1) (null? set2)) '())
          ((element-of-set? (car set1) set2)
           (cons (car set1)
                 (intersection-set (cdr set1) set2)))
          (else (intersection-set (cdr set1) set2))))
#+END_SRC
其中 =element-of-set?= 和 =intersection-set= 操作依然需要遍历表, 由于允许元素重
复, 表长度相应增大, 所以这两项操作效率变低, 而 =adjoin-set= 和 =union-set= 操作
仅需常数时间即可完成. 当具体应用中操作大多数为添加和并操作时更倾向于使用该种表示.

* Exercise2.61
=adjoin-set= 依然使用 =element-of-set?= 来实现, 由于 =element-of-set?= 平均所需步数为采用未排序时表示的一半, =adjoin-set= 也为一半.

* Exercise2.62
在集合的排序表示上的一个\Theta(n)的实现如下:
#+Name: union-set.csm
#+BEGIN_SRC scheme
  (define (union-set set1 set2)
    (cond ((null? set1) set2)
          ((null? set2) set1)
          (else (let ((x1 (car set1)) (x2 (car set2)))
                  (cond ((= x1 x2)
                         (cons x1
                               (union-set (cdr set1)
                                          (cdr set2))))
                        ((< x1 x2)
                         (cons x1
                               (union-set (cdr set1) set2)))
                        ((< x2 x1)
                         (cons x2
                               (union-set set1 (cdr set2)))))))))
#+END_SRC

* TODO Exercise2.63
1. 这两个过程都产生树的中序遍历结果.
2. 两个过程做了相同数量的 =cons= 操作, 具有同样量级的增长速度.

* Exercise2.64
1. =partial-tree= 在每次递归时将所有结点分为两半, 这样保证了对于生成树的任意一
   个结点, 其左子树与右子树结点数差不超过1, 因此该生成树是平衡二叉树. 将
   =paritial-tree= 用于表 =(1 3 5 7 9)= 产生的树为:
   #+Name: Output
   #+BEGIN_SRC scheme
     (5 (1 ()
           (3 ()
              ()))
        (9 (7 ()
              ())
           (11 ()
               ())))
   #+END_SRC
2. 由程序的递归关系可得 =T(n) = 2 * T(n / 2) + \Theta(1)=, 所以转换n个元素的表
   所需的步数以 \Theta(n) 为量级.

* TODO Exercise2.65
TODO 实现基于平衡二叉树版本的交集和并集操作.

* Exercise2.66
对于采用二叉树实现的集合, 定义 =lookup= 过程如下:
#+Name: lookup.scm
#+BEGIN_SRC scheme
  (define (lookup given-key set-of-records)
    (cond ((null? set-of-records) #f)
          ((= given-key (key (car set-of-records)))
           (car set-of-records))
          ((< given-key (key (car set-of-records)))
           (lookup (left-branch set-of-records)))
          (else (lookup (right-branch set-of-records)))))
#+END_SRC

* Exercise2.67
定义样例编码树和样例消息如下:
#+Name: sample.scm
#+BEGIN_SRC scheme
  (define sample-tree
    (make-code-tree (make-leaf 'A 4)
                    (make-code-tree
                     (make-leaf 'B 2)
                     (make-code-tree (make-leaf 'D 1)
                                     (make-leaf 'C 1)))))

  (define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
#+END_SRC
使用过程 =decode= 得到的编码结果为:
#+Name: Output
#+BEGIN_SRC
  scheme@(guile-user)> (decode sample-message sample-tree)
  $1 = (A D A B B C A)

#+END_SRC

* Exercise2.68
过程 =encode= 的定义如下:
#+Name: encode.scm
#+BEGIN_SRC scheme
  (define (encode message tree)
    (if (null? message)
        '()
        (append (encode-symbol (car message) tree)
                (encode (cdr message) tree))))

  (define (encode-symbol symbol tree)
    (cond ((leaf? tree) '())
          ((contains? symbol (symbols (left-branch tree)))
           (cons 0 (encode-symbol symbol (left-branch tree))))
          ((contains? symbol (symbols (right-branch tree)))
           (cons 1 (encode-symbol symbol (right-branch tree))))
          (else (error "unknow symbol" symbol))))

  (define (contains? e list)
    (cond ((null? list) #f)
          ((eq? e (car list)) #t)
          (else (contains? e (cdr list)))))
#+END_SRC

* Exercise2.69
根据符号-频度对偶表生成Huffman编码树的过程实现如下:
#+Name: generate-huffman-tree.scm
#+BEGIN_SRC scheme
  (define (generate-huffman-tree pairs)
    (successive-merge (make-leaf-set pairs)))

  (define (successive-merge set)
    (cond ((null? (cddr set))
           (make-code-tree (car set) (cadr set)))
          (else
           (successive-merge
            (adjoin-set (make-code-tree (car set) (cadr set))
                        (cddr set))))))
#+END_SRC

* Exercise2.70
定义8个符号的字母频度表和文本消息:
#+Name: Exercise
#+BEGIN_SRC scheme
  (define pairs
    '((a 2) (na 16) (boom 1) (sha 3) (get 2) (yip 9) (job 2) (wah 1)))

  (define message
    '(get a job sha na na na na na na na na get a job sha na na na na na na
          na na wah yip yip yip yip yip yip yip yip yip sha boom))
#+END_SRC
利用huffman编码过程生成的编码为:
#+Name: Output
#+BEGIN_SRC
  scheme@(guile-user)> (encode message (generate-huffman-tree pairs))
  $1 = (1 1 1 1 1 1 1 0 0 1 1 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 0 1 1 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0 1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 0 1 1 0 1 1)

#+END_SRC
这一编码一共使用了88个二进制位. 若采用定长编码, 每个符号需要3个二进制位, 完成这
个歌曲最少需要 =36 * 4 = 144= 个二进制位.

* Exercise2.71
对于这样的编码, 出现最频繁的符号要用1个二进制位表示, 最不频繁的符号要用 =n - 1=
个二进制位表示.

* Exercise2.72
当符号的相对频率满足如2.71中所描述的规则时, 编码最频繁的符号所需的步数的增长速
率为 \Theta(1), 最不频繁的符号所需步数的增长速率为 \Thead(n^2).

* Exercise2.73
1. 数据导向的求导程序根据表达式的操作类型的不同选择不同的求导过程. 由于数字和符
   号并非一种操作, 所以无法将 =number?= 和 =same-variable?= 也加入数据导向分派中.
2. 针对和式和积式的求导过程实现如下:
   #+Name: deriv1.scm
   #+BEGIN_SRC scheme
     (define (install-deriv-package)
       (define (deriv-sum exp var)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
       (define (deriv-product exp var)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp)))))

     (put 'deriv-sum '(+) deriv-sum)
     (put 'deriv-product '(*) deriv-product)
   #+END_SRC
3. TODO 添加其他操作的求导程过
4. 求导系统不是以求导实现方式分类, 而是按操作实现方式来分类.

* Exercise2.74
通过为每个操作定义针对不同分支机构的特定版本, 然后将这些操作注册到一个统一的表
中, 然后实现一个过程可以从该表中根据不同的分支机构选择恰当的实现来执行操作.
1. =get-recode= 过程
   #+Name: get-recode.scm
   #+BEGIN_SRC scheme
     (define (get-record file)
       ((get 'get-record (institute file)) file))
   #+END_SRC
   各个独立机构的文件应该提供其机构的唯一标识.
2. =get-salary= 过程
   #+Name: get-salary.scm
   #+BEGIN_SRC scheme
     (define (get-salary file employee)
       ((get 'get-salary (insitute file)) file employee))
   #+END_SRC
3. =find-employee-record= 过程
   #+Name: find-employee-record.scm
   #+BEGIN_SRC scheme
     (define (find-employee-record employee-name file-list)
       (if (null? file-list)
           '()
           (cons ((get 'find-employee-record (institute (car file-list)))
                  employee-name (car file-list))
                 (find-employee-record (cdr file-list)))))
   #+END_SRC
4. 要将新的人事文件结合到系统, 要将这些文件标记特定的机构标识, 还要实现现有操作
   相应与该机构的特定版本.

* Exercise2.75
使用消息传递的方式实现 =make-from-mag-ang= 过程如下:
#+Name: make-from-mag-ang.scm
#+BEGIN_SRC scheme
  (define (make-from-mag-ang m a)
    (define (dispatch op)
      (cond ((eq? op 'real-part)
             (* m (cos a)))
            ((eq? op 'imag-part)
             (* m (sin a)))
            ((eq? op 'magnitude) m)
            ((eq? op 'angle) a)
            (else
             (error "Unknow op -- MAKE-FROM-REAL-IMAG" op))))
    dispatch)
#+END_SRC

* Exercise2.76
1. 显式分派风格
   不管是加入新类型还是新操作, 都需要修改原来的通用过程;
2. 数据导向风格
   加入新类型或新操作不需要改变原有的程序, 只需要将对应的新操作加入表中;
3. 消息传递风格
   加入新类型不需要修改原有代码, 但加入新操作需要.

消息传递风格最是个需要经常加入新类型的系统, 数据导向风格的组织方式最适合需要经常
加入新操作的系统.
