#+TITLE: SICP Solutions: Chapter2
#+AUTHOR: Orab
#+STARTUP: indent
#+TODO: TODO TOVERIFY |

* Exercise2.1
对于一个分数而言, 只有当分子分母同时取负时值不变, 所以如果要保证分母始终为正值,
只需要在分母为负时对分子分母同时取负即可.

=make-rat= 的更好版本定义如下:
#+Name: make-rat.scm
#+BEGIN_SRC scheme
  (define (make-rat numer denom)
    (let ((g (gcd numer denom)))
        (if (< (/ denom g) 0)
            (cons (- (/ numer g)) (- (/ denom g)))
            (cons (/ numer g) (/ denom g)))))

#+END_SRC

* Exercise2.2
平面上线段表示的定义实现如下:
#+Name: segment.scm
#+BEGIN_SRC scheme
  (define (make-segment start end)
    (cons start end))
  (define (start-segment segment)
    (car segment))
  (define (end-segment segment)
    (cdr segment))

  (define (make-point x y)
    (cons x y))
  (define (x-point point)
    (car point))
  (define (y-point point)
    (cdr point))

  (define (print-point point)
    (newline)
    (display "(")
    (display (x-point point))
    (display ",")
    (display (y-point point))
    (display ")"))

  (define (midpoint-segment segment)
    (make-point (/ (+ (x-point (start-segment segment))
                      (x-point (end-segment segment)))
                   2)
                (/ (+ (y-point (start-segment segment))
                      (y-point (end-segment segment)))
                   2)))

#+END_SRC
验证输出结果为:
#+Name: Output
#+BEGIN_SRC shell
  scheme@(guile-user)> (define x (make-point 2 9))
  scheme@(guile-user)> (define y (make-point 4 8))
  scheme@(guile-user)> (define seg (make-segment x y))
  scheme@(guile-user)> (define mp (midpoint-segment seg))
  scheme@(guile-user)> (print-point mp)

  (3,17/2)

#+END_SRC

* TODO Exercise2.3
TODO: 平面矩形是否需要确定位置及旋转角度等信息, 如果需要该怎样实现?

* Exercise2.4
利用代换模型, 将 =car= 过程依次展开的结果为:
#+Name: verify
#+BEGIN_SRC scheme
  (car (cons x y))
  ((cons x y) (lambda (p q) p))
  ((lambda (m) (m x y)) (lambda (p q) p))
  ((lambda (p q) p) x y)
  x

#+END_SRC

对应的 =cdr= 的定义为:
#+Name: cdr.scm
#+BEGIN_SRC scheme
  (define (cdr z)
    (z (lambda (p q) q)))
#+END_SRC

* Exercise2.5
由于2的幂和3的幂不存在大于1的公约数, 所以分别找出可以整除的2的最大次幂和可以整
除的3的最大次幂的结果就可以确定a和b的值.

过程定义如下:
#+Name: cons-power.scm
#+BEGIN_SRC scheme
  (define (power x n)
    (if (= n 1)
        x
        (* x (power x (- n 1)))))

  (define (cons a b)
    (* (power 2 a)
       (power 3 b)))
  (define (car z)
    (if (= 0 (remainder z 2))
        (+ 1 (car (/ z 2)))
        0))
  (define (cdr z)
    (if (= 0 (remainder z 3))
        (+ 1 (cdr (/ z 3)))
        0))
#+END_SRC

* Exercise2.6
通过代换Church计数的 =zero= 和 =add-1= 到 =(add-1 zero)= 中, 结果如下:
#+Name: one.scm
#+BEGIN_SRC scheme
  (add-1 zero)
  (lambda (f) (lambda (x) (f ((zero f) x))))
  (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x))))
  (lambda (f) (lambda (x) (f ((lambda (x) x) x))))
  (lambda (f) (lambda (x) (f x)))
#+END_SRC
即 =one= 的定义式为 =(lambda (f) (lambda (x) (f x)))=.

再将 =one= 和 =add-1= 代入到 =(add-1 one)= 中, 结果如下:
#+Name: two.scm
#+BEGIN_SRC scheme
  (add-1 two)
  (lambda (f) (lambda (x) (f ((one f) x))))
  (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f x))) f) x))))
  (lambda (f) (lambda (x) (f ((lambda (x) (f x)) x))))
  (lambda (f) (lambda (x) (f (f x))))
#+END_SRC
即 =two= 的定义式为 =(lambda (f) (lambda (x) (f (f x))))=.

经过上面的代换可以看出 =add-1= 的过程实际上相当于在原来的过程中增加了一个 =f=
函数的迭代调用, 而加法的定义可以看做是 =add-n= 的过程, 即要在原来的过程中增加n
个 =f= 函数的迭代调用, 等于用Church计数时数n中 =f= 函数迭代调用的次数.

因此加法过程的一个直接定义为:
#+Name: add.scm
#+BEGIN_SRC scheme
  (define (+ a b)
    (lambda (f) (lambda (x) ((a f) ((b f) x)))))
#+END_SRC

* Exercise2.7
区间构造的完整基础定义如下:
#+Name: interval.scm
#+BEGIN_SRC scheme
  (define (make-interval a b) (cons a b))
  (define (upper-bound interval)
    (if (> (car interval) (cdr interval))
        (car interval)
        (cdr interval)))
  (define (lower-bound interval)
    (if (< (car interval) (cdr interval))
        (car interval)
        (cdr interval)))

#+END_SRC

* Exercise2.8
对于两个区间的减法来说, 最大值为减数的上界减去被减数的下界, 最小值为减数的下界
减去被减数的上界. 具体定义如下:
#+Name sub-interval.scm
#+BEGIN_SRC scheme
  (define (sub-interval x y)
    (make-interval (- (upper-bound x) (lower-bound y))
                   (- (lower-bound x) (upper-bound y))))
#+END_SRC

* Exercise2.9
我们可以通过一般化的推导来证明题中的结论:

假设两个区间分别为 =(a1, b1)=, =(a2, b2)=, 则它们的和为 =(a1 + a2, b1 + b2)=,两
个区间的宽度分别为 =b1 - a1=, =b2 - a2=, 而它们和的宽度为 =(b1 + b2) - (a1 +
a2) = (b1 - a1) + (b2 - a2)=, 即两个区间的和的宽度等于两个区间宽度的和. 减法的过
程同样如此, 上述两个区间的差为 =(a1 - b2, b1 - a2)=, 它们差的宽度为 =(b1 -
a2) - (a1 - b2) = (b1 - a1) - (b2 - a2)=, 两个区间的差的宽度等于两个区间宽度的差.

对于乘和除而言并不满足这样的关系, 例如区间 =(1, 4)= 和 =(3, 9)= 的区间宽度分别
为 =3= 和 =6=, 它们的乘积为 =(3, 36)=, 乘积宽度为 =33=, 而宽度的乘积为 =18=; 它
们的商为 =(1/9, 4/3)=, 商宽度为 =10/9=, 而宽度的商为 =1/2=.

* Exercise2.10
修正 =div-interval= 的过程为:
#+Name: div-interval.scm
#+BEGIN_SRC scheme
  (define (div-interval x y)
    (if (<= 0 (* (upper-bound y) (lower-bound y)))
        (error "The interval contains zeros in divider")
        (mul-interval x
                      (make-interval (/ 1.0 (upper-bound y))
                                     (/ 1.0 (lower-bound y))))))
#+END_SRC

* TODO Exercise2.11
重写 =mul-interval= 的过程如下:
#+Name: mul-interval.scm
#+BEGIN_SRC scheme
#+END_SRC

* Exercise2.12
=make-center-percent= 的过程定义如下:
#+Name: center-percent.scm
#+BEGIN_SRC scheme
  (define (make-center-percent c p)
    (make-interval (- c (* c p))
                   (+ c (* c p))))
  (define (center i)
    (/ (+ (lower-bound i) (upper-bound i)) 2))
  (define (percent i)
    (/ (/ (- (upper-bound i) (lower-bound i)) 2)
       (/ (+ (upper-bound i) (lower-bound i)) 2)))
#+END_SRC

* Exercise2.13
设两个区间分别为 =(x - ax, x + ax)=, =(y - by, y + by)=, 它们的乘积宽度为
=(xy + axy + bxy + abxy) - (xy - axy - bxy + abxy) = 2(a + b)xy=, 当百分比很小时,
乘积本身可看做 =(xy - (a + b)xy, xy + (a + b)xy)=, 所以两个被乘区间的百分误差可
看做各自百分误差之和.
