#+TITLE: SICP Solutions: Chapter2
#+AUTHOR: Orab
#+STARTUP: indent
#+TODO: TODO TOVERIFY | VERIFIED

* Exercise2.1
对于一个分数而言, 只有当分子分母同时取负时值不变, 所以如果要保证分母始终为正值,
只需要在分母为负时对分子分母同时取负即可.

=make-rat= 的更好版本定义如下:
#+Name: make-rat.scm
#+BEGIN_SRC scheme
  (define (make-rat numer denom)
    (let ((g (gcd numer denom)))
        (if (< (/ denom g) 0)
            (cons (- (/ numer g)) (- (/ denom g)))
            (cons (/ numer g) (/ denom g)))))

#+END_SRC

* Exercise2.2
平面上线段表示的定义实现如下:
#+Name: segment.scm
#+BEGIN_SRC scheme
  (define (make-segment start end)
    (cons start end))
  (define (start-segment segment)
    (car segment))
  (define (end-segment segment)
    (cdr segment))

  (define (make-point x y)
    (cons x y))
  (define (x-point point)
    (car point))
  (define (y-point point)
    (cdr point))

  (define (print-point point)
    (newline)
    (display "(")
    (display (x-point point))
    (display ",")
    (display (y-point point))
    (display ")"))

  (define (midpoint-segment segment)
    (make-point (/ (+ (x-point (start-segment segment))
                      (x-point (end-segment segment)))
                   2)
                (/ (+ (y-point (start-segment segment))
                      (y-point (end-segment segment)))
                   2)))

#+END_SRC
验证输出结果为:
#+Name: Output
#+BEGIN_SRC shell
  scheme@(guile-user)> (define x (make-point 2 9))
  scheme@(guile-user)> (define y (make-point 4 8))
  scheme@(guile-user)> (define seg (make-segment x y))
  scheme@(guile-user)> (define mp (midpoint-segment seg))
  scheme@(guile-user)> (print-point mp)

  (3,17/2)

#+END_SRC

* TODO Exercise2.3
TODO: 平面矩形是否需要确定位置及旋转角度等信息, 如果需要该怎样实现?

* Exercise2.4
利用代换模型, 将 =car= 过程依次展开的结果为:
#+Name: verify
#+BEGIN_SRC scheme
  (car (cons x y))
  ((cons x y) (lambda (p q) p))
  ((lambda (m) (m x y)) (lambda (p q) p))
  ((lambda (p q) p) x y)
  x

#+END_SRC

对应的 =cdr= 的定义为:
#+Name: cdr.scm
#+BEGIN_SRC scheme
  (define (cdr z)
    (z (lambda (p q) q)))
#+END_SRC

* Exercise2.5
由于2的幂和3的幂不存在大于1的公约数, 所以分别找出可以整除的2的最大次幂和可以整
除的3的最大次幂的结果就可以确定a和b的值.

过程定义如下:
#+Name: cons-power.scm
#+BEGIN_SRC scheme
  (define (power x n)
    (if (= n 1)
        x
        (* x (power x (- n 1)))))

  (define (cons a b)
    (* (power 2 a)
       (power 3 b)))
  (define (car z)
    (if (= 0 (remainder z 2))
        (+ 1 (car (/ z 2)))
        0))
  (define (cdr z)
    (if (= 0 (remainder z 3))
        (+ 1 (cdr (/ z 3)))
        0))
#+END_SRC

* Exercise2.6
通过代换Church计数的 =zero= 和 =add-1= 到 =(add-1 zero)= 中, 结果如下:
#+Name: one.scm
#+BEGIN_SRC scheme
  (add-1 zero)
  (lambda (f) (lambda (x) (f ((zero f) x))))
  (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x))))
  (lambda (f) (lambda (x) (f ((lambda (x) x) x))))
  (lambda (f) (lambda (x) (f x)))
#+END_SRC
即 =one= 的定义式为 =(lambda (f) (lambda (x) (f x)))=.

再将 =one= 和 =add-1= 代入到 =(add-1 one)= 中, 结果如下:
#+Name: two.scm
#+BEGIN_SRC scheme
  (add-1 two)
  (lambda (f) (lambda (x) (f ((one f) x))))
  (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f x))) f) x))))
  (lambda (f) (lambda (x) (f ((lambda (x) (f x)) x))))
  (lambda (f) (lambda (x) (f (f x))))
#+END_SRC
即 =two= 的定义式为 =(lambda (f) (lambda (x) (f (f x))))=.

经过上面的代换可以看出 =add-1= 的过程实际上相当于在原来的过程中增加了一个 =f=
函数的迭代调用, 而加法的定义可以看做是 =add-n= 的过程, 即要在原来的过程中增加n
个 =f= 函数的迭代调用, 等于用Church计数时数n中 =f= 函数迭代调用的次数.

因此加法过程的一个直接定义为:
#+Name: add.scm
#+BEGIN_SRC scheme
  (define (+ a b)
    (lambda (f) (lambda (x) ((a f) ((b f) x)))))
#+END_SRC

* Exercise2.7
区间构造的完整基础定义如下:
#+Name: interval.scm
#+BEGIN_SRC scheme
  (define (make-interval a b) (cons a b))
  (define (upper-bound interval)
    (if (> (car interval) (cdr interval))
        (car interval)
        (cdr interval)))
  (define (lower-bound interval)
    (if (< (car interval) (cdr interval))
        (car interval)
        (cdr interval)))

#+END_SRC

* Exercise2.8
对于两个区间的减法来说, 最大值为减数的上界减去被减数的下界, 最小值为减数的下界
减去被减数的上界. 具体定义如下:
#+Name sub-interval.scm
#+BEGIN_SRC scheme
  (define (sub-interval x y)
    (make-interval (- (upper-bound x) (lower-bound y))
                   (- (lower-bound x) (upper-bound y))))
#+END_SRC

* Exercise2.9
我们可以通过一般化的推导来证明题中的结论:

假设两个区间分别为 =(a1, b1)=, =(a2, b2)=, 则它们的和为 =(a1 + a2, b1 + b2)=,两
个区间的宽度分别为 =b1 - a1=, =b2 - a2=, 而它们和的宽度为 =(b1 + b2) - (a1 +
a2) = (b1 - a1) + (b2 - a2)=, 即两个区间的和的宽度等于两个区间宽度的和. 减法的过
程同样如此, 上述两个区间的差为 =(a1 - b2, b1 - a2)=, 它们差的宽度为 =(b1 -
a2) - (a1 - b2) = (b1 - a1) - (b2 - a2)=, 两个区间的差的宽度等于两个区间宽度的差.

对于乘和除而言并不满足这样的关系, 例如区间 =(1, 4)= 和 =(3, 9)= 的区间宽度分别
为 =3= 和 =6=, 它们的乘积为 =(3, 36)=, 乘积宽度为 =33=, 而宽度的乘积为 =18=; 它
们的商为 =(1/9, 4/3)=, 商宽度为 =10/9=, 而宽度的商为 =1/2=.

* Exercise2.10
修正 =div-interval= 的过程为:
#+Name: div-interval.scm
#+BEGIN_SRC scheme
  (define (div-interval x y)
    (if (>= 0 (* (upper-bound y) (lower-bound y)))
        (error "The interval contains zeros in divider")
        (mul-interval x
                      (make-interval (/ 1.0 (upper-bound y))
                                     (/ 1.0 (lower-bound y))))))
#+END_SRC

* TODO Exercise2.11
重写 =mul-interval= 的过程如下:
#+Name: mul-interval.scm
#+BEGIN_SRC scheme
#+END_SRC

* Exercise2.12
=make-center-percent= 的过程定义如下:
#+Name: center-percent.scm
#+BEGIN_SRC scheme
  (define (make-center-percent c p)
    (make-interval (- c (* c p))
                   (+ c (* c p))))
  (define (center i)
    (/ (+ (lower-bound i) (upper-bound i)) 2))
  (define (percent i)
    (/ (/ (- (upper-bound i) (lower-bound i)) 2)
       (/ (+ (upper-bound i) (lower-bound i)) 2)))
#+END_SRC

* Exercise2.13
设两个区间分别为 =(x - ax, x + ax)=, =(y - by, y + by)=, 它们的乘积宽度为
=(xy + axy + bxy + abxy) - (xy - axy - bxy + abxy) = 2(a + b)xy=, 当百分比很小时,
乘积本身可看做 =(xy - (a + b)xy, xy + (a + b)xy)=, 所以两个被乘区间的百分误差可
看做各自百分误差之和.

* TOVERIFY Exercise2.14
1. 通过程序验证, 得到的输出如下:
   #+Name: Output
   #+BEGIN_SRC
     scheme@(guile-user)> (define r1 (make-interval 2 4))
     scheme@(guile-user)> (define r2 (make-interval 3 8))
     scheme@(guile-user)> (par1 r1 r2)
     $1 = (0.5 . 6.4)
     scheme@(guile-user)> (par2 r1 r2)
     $2 = (1.2000000000000002 . 2.6666666666666665)

   #+END_SRC
   可以看到两种方式所得到的结果完全不同.

2. 按照中心-百分比形式进行除法检验的输出为:
   #+Name: Output
   #+BEGIN_SRC
     scheme@(guile-user)> (define A (make-interval 60 62))
     scheme@(guile-user)> (define B (make-interval 30 33))
     scheme@(guile-user)> (div-interval A A)
     $1 = (0.967741935483871 . 1.0333333333333332)
     scheme@(guile-user)> (div-interval A B)
     $2 = (1.8181818181818183 . 2.0666666666666664)
     scheme@(guile-user)> (define A (make-center-percent 60 0.01))
     scheme@(guile-user)> (define B (make-center-percent 30 0.02))
     scheme@(guile-user)> (define r1 (div-interval A A))
     scheme@(guile-user)> (center r1)
     $3 = 1.000200020002
     scheme@(guile-user)> (percent r1)
     $4 = 0.019998000199980024scheme
     @(guile-user)> (define r2 (div-interval A B))
     scheme@(guile-user)> (center r2)
     $5 = 2.001200480192077
     scheme@(guile-user)> (percent r2)
     $6 = 0.02999400119976012

   #+END_SRC
   可以看出两个相同区间作除法并没有得到理论上的标准单位元. 商的误差百分比大致相
   当于被除数和除数的误差百分比之和, 即所做运算使误差区间增大.

* TODO Exercise2.15
* TODO Exercise2.16
* Exercise2.17
过程 =last-pair= 的定义如下:
#+Name: last-pair.scm
#+BEGIN_SRC scheme
  (define (last-pair list)
    (if (null? (cdr list))
        list
        (last-pair (cdr list))))
#+END_SRC

* Exercise2.18
过程 =reverse= 的定义如下:
#+Name reverse.scm
#+BEGIN_SRC scheme
  (define (reverse list)
    (if (null? list)
        '()
        (append (reverse (cdr list))
              (cons (car list) '()))))
#+END_SRC

* Exercise2.19
兑换零钱方式计数的改进版本定义如下:
#+Name: cc.scm
#+BEGIN_SRC scheme
  (define us-coins (list 50 25 10 5 1))
  (define uk-coins (list 100 50 20 10 5 2 1 0.5))

  (define (cc amount coin-values)
    (cond ((= amount 0) 1)
          ((or (< amount 0) (no-more? coin-values)) 0)
          (else
           (+ (cc amount
                  (except-first-denomination coin-values))
              (cc (- amount
                     (first-denomination coin-values))
                  coin-values)))))

  (define (no-more? coin-values)
    (null? coin-values))

  (define (except-first-denomination coin-values)
    (cdr coin-values))

  (define (first-denomination coin-values)
    (car coin-values))
#+END_SRC
表 =coin-values= 的排列顺序不会影响cc给出的答案, 因为
=except-first-denomination= 和 =first-denomination= 的过程包含了所有可能的情况,
即任何一种可能的情况要么出现在第一种情况中, 要么出现在第二种情况中, 而与顺序无关.

* Exercise2.20
过程 =same-parity= 的定义如下:
#+Name: same-parity.scm
#+BEGIN_SRC scheme
  (define (same-parity x . list)
    (let ((same? (if (even? x)
                     even?
                     odd?)))
      (define (parity list)
        (cond ((null? list) '())
              ((same? (car list))
               (cons (car list) (parity (cdr list))))
              (else (parity (cdr list)))))
      (cons x (parity list))))
#+END_SRC

* Exercise2.21
过程 =square-list= 的两个定义的补全如下:
#+Name: square-list.scm
#+BEGIN_SRC scheme
  (define (square-list items)
    (if (null? items)
        '()
        (cons (square (car items))
              (square-list (cdr items)))))

  (define (square-list items)
    (map (lambda (x) (square x))
         items))
#+END_SRC

* Exercise2.22
1. 按第一种方式产生出的结果中, 因为items中先被取出(car)的元素会先被加入结果的表
   中, 这样原表中的元素在新表中会在与之对称的位置, 即元素的顺序正好相反.
2. 按照第二种方式, 说得结果中每个cons的第二个元素都指向一个实际值, 与表定义所要
   求的正好相反.

* Exercise2.23
过程 =for-each= 的一个实现如下:
#+Name: for-each.scm
#+BEGIN_SRC scheme
  (define (for-each f items)
    (cond ((null? items) #t)
          (else
           (f (car items))
           (for-each f (cdr items)))))
#+END_SRC

* TODO Exercise2.24
解释器打印的结果为 =(1 (2 (3 4)))=.
TODO: 图形化显示对应的盒状指针结构.

* Exercise2.25
从下面各表中取出7的 =car= 和 =cdr= 的组合为:
#+Name: Solutions
#+BEGIN_SRC scheme
  ;; (1 3 (5 7) 9)
  (define x '(1 3 (5 7) 9))
  (car (cdr (car (cdr (cdr x)))))

  ;; ((7))
  (define y '((7)))
  (car (car y))

  ;; (1 (2 (3 (4 (5 (6 7))))))
  (define z '(1 (2 (3 (4 (5 (6 7)))))))
  (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr z))))))))))))
#+END_SRC

* Exercise2.26
各个表达式的打印结果如下:
#+Name: Solutions
#+BEGIN_SRC scheme
  ;; x: (1 2 3) y: (4 5 6)

  ;; (append x y)
  (1 2 3 4 5 6)

  ;; (cons x y)
  ((1 2 3) 4 5 6)

  ;; (list x y)
  ((1 2 3) (4 5 6))
#+END_SRC

* Exercise2.27
过程 =deep-reverse= 的定义如下:
#+Name: deep-reverse.scm
#+BEGIN_SRC scheme
  (define (deep-reverse tree)
    (cond ((null? tree) '())
          ((not (pair? tree)) tree)
          (else (append (deep-reverse (cdr tree))
                        (cons (deep-reverse (car tree))
                              '())))))
#+END_SRC

* Exercise2.28
过程 =fringe= 的定义如下:
#+Name: fringe.scm
#+BEGIN_SRC scheme
  (define (fringe tree)
    (cond ((null? tree) '())
          ((not (pair? (car tree)))
           (cons (car tree) (fringe (cdr tree))))
          (else (append (fringe (car tree))
                        (fringe (cdr tree))))))
#+END_SRC

* Exercise2.29
1. =branch= 的一些简单操作定义如下:
   #+Name: branch.scm
   #+BEGIN_SRC scheme
     (define (make-mobile left right)
       (list left right))

     (define (make-branch length structure)
       (list length structure))

     (define (left-branch mobile)
       (car mobile))

     (define (right-branch mobile)
       (car (cdr mobile)))

     (define (branch-length branch)
       (car branch))

     (define (branch-structure branch)
       (car (cdr branch)))
   #+END_SRC
2. 过程 =total-weight= 的定义如下:
   #+Name: total-weight.scm
   #+BEGIN_SRC scheme
     (define (total-weight mobile)
       (cond ((null? mobile) 0)
             ((not (pair? mobile)) mobile)
             (else
              (+ (total-weight
                  (branch-structure (left-branch mobile)))
                 (total-weight
                  (branch-structure (right-branch mobile)))))))
   #+END_SRC
3. 检查一个二叉活动体是否平衡的过程 =balance?= 的定义如下:
   #+Name: balance?.scm
   #+BEGIN_SRC scheme
     (define (balance? mobile)
       (if (or (null? mobile) (not (pair? mobile)))
           #t
           (and (= (* (branch-length (left-branch mobile))
                      (total-weight
                       (branch-structure (left-branch mobile))))
                   (* (branch-length (right-branch mobile))
                      (total-weight
                       (branch-structure (right-branch mobile)))))
                (balance? (branch-structure (left-branch mobile)))
                (balance? (branch-structure (right-branch mobile))))))
   #+END_SRC
4. 如果改变活动体的构造方式, 要保持程序仍旧可用, 只需修改对应的选择函数即可:
   #+Name: branch-modified.scm
   #+BEGIN_SRC scheme
     (define (make-mobile left right)
       (cons left right))

     (define (make-branch length structure)
       (cons length structure))

     (define (left-branch mobile)
       (car mobile))

     (define (right-branch mobile)
       (cdr mobile))

     (define (branch-length branch)
       (car branch))

     (define (branch-structure branch)
       (cdr branch))
   #+END_SRC

* Exercise2.30
使用递归定义 =square-tree= 的过程如下:
#+Name: square-tree.scm
#+BEGIN_SRC scheme
  (define (square-tree tree)
    (cond ((null? tree) '())
          ((not (pair? tree)) (square tree))
          (else (cons (square-tree (car tree))
                      (square-tree (cdr tree))))))
#+END_SRC
使用 =map= 定义 =square-tree= 的过程如下:
#+Name: square-tree.scm
#+BEGIN_SRC scheme
  (define (square-tree tree)
    (map (lambda (subtree)
           (if (pair? subtree)
               (square-tree subtree)
               (square subtree)))
         tree))
#+END_SRC

* Exercise2.31
利用 =map= 做进一步的抽象过程 =tree-map=, 过程定义如下:
#+Name: tree-map.scm
#+BEGIN_SRC scheme
  (define (tree-map func tree)
    (map (lambda (subtree)
           (if (pair? subtree)
               (tree-map func subtree)
               (func subtree)))
         tree))
#+END_SRC

* Exercise2.32
过程 =subsets= 的完整定义如下:
#+Name: subsets.scm
#+BEGIN_SRC scheme
  (define (subsets s)
    (if (null? s)
        (list '())
        (let ((rest (subsets (cdr s))))
          (append rest (map (lambda (x) (cons (car s) x)) rest)))))
#+END_SRC
一个集合的所有子集可以看作是包含第一个元素的子集和不包含第一个元素的子集的总和.

* Exercise2.33
完整的表达式如下:
#+Name: Solutions
#+BEGIN_SRC scheme
  ;; 1)
  (define (map p sequence)
    (accumulate (lambda (x y) (cons (p x) y)) '() sequence))

  ;; 2)
  (define (append seq1 seq2)
    (accumulate cons seq2 seq1))

  ;; 3)
  (define (length sequence)
    (accumulate (lambda (x y) (+ 1 y)) 0 sequence))
#+END_SRC

* Exercise2.34
利用Horner规则求多项式值的完整过程定义如下:
#+Name: horner-eval.scm
#+BEGIN_SRC scheme
  (define (horner-eval x coefficient-sequence)
    (accumulate (lambda (this-coeff higher-terms)
                  (+ this-coeff (* x higher-terms)))
                0
                coefficient-sequence))
#+END_SRC

* TODO Exercise2.35
用累积的形式重新定义 =count-leaves= 的过程如下:
#+Name: count-leaves.scm
#+BEGIN_SRC scheme

#+END_SRC
