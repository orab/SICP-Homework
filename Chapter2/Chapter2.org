#+TITLE: SICP Solutions: Chapter2
#+AUTHOR: Orab

#+STARTUP: indent content entitiespretty latexpreview
#+OPTIONS: ^:{}
#+TODO: TODO(t) TOVERIFY(v) | VERIFIED(d)

* Exercise2.1
对于一个分数而言, 只有当分子分母同时取负时值不变, 所以如果要保证分母始终为正值,只需要在分母为负时对分子分母同时取负即可.

~make-rat~ 的更好版本定义如下:
#+Name: make-rat.scm
#+BEGIN_SRC scheme
  (define (make-rat numer denom)
    (let ((g (gcd numer denom)))
        (if (< (/ denom g) 0)
            (cons (- (/ numer g)) (- (/ denom g)))
            (cons (/ numer g) (/ denom g)))))

#+END_SRC

* Exercise2.2
平面上线段表示的定义实现如下:
#+Name: segment.scm
#+BEGIN_SRC scheme
  (define (make-segment start end)
    (cons start end))
  (define (start-segment segment)
    (car segment))
  (define (end-segment segment)
    (cdr segment))

  (define (make-point x y)
    (cons x y))
  (define (x-point point)
    (car point))
  (define (y-point point)
    (cdr point))

  (define (print-point point)
    (newline)
    (display "(")
    (display (x-point point))
    (display ",")
    (display (y-point point))
    (display ")"))

  (define (midpoint-segment segment)
    (make-point (/ (+ (x-point (start-segment segment))
                      (x-point (end-segment segment)))
                   2)
                (/ (+ (y-point (start-segment segment))
                      (y-point (end-segment segment)))
                   2)))

#+END_SRC
验证输出结果为:
#+Name: Output
#+BEGIN_SRC shell
  scheme@(guile-user)> (define x (make-point 2 9))
  scheme@(guile-user)> (define y (make-point 4 8))
  scheme@(guile-user)> (define seg (make-segment x y))
  scheme@(guile-user)> (define mp (midpoint-segment seg))
  scheme@(guile-user)> (print-point mp)

  (3,17/2)

#+END_SRC

* Exercise2.3
*假设所有矩形的边与x轴, y轴分别平行.*

可以通过左上角和右下角的两个点来定义平面上的矩形:
#+BEGIN_SRC scheme
  (define (make-rect p-lefttop p-rightbottom)
    (cons p-lefttop p-rightbottom))

  (define (rect-width rect)
    (- (point-x (cdr rect))
       (point-x (car rect))))

  (define (rect-height rect)
    (- (point-y (car rect))
       (point-y (cdr rect))))
#+END_SRC
使用该定义来计算矩形的周长和面积, 过程如下:
#+BEGIN_SRC scheme
  (define (rect-perimeter rect)
    (* 2 (+ (rect-width rect)
            (rect-height rect))))

  (define (rect-area rect)
    (* (rect-width rect)
       (rect-height rect)))
#+END_SRC
另外一种表示矩形的方法可以使用左边的线段和下边的线段来定义:
#+BEGIN_SRC scheme
  (define (make-rect s-left s-bottom)
    (cons s-left s-bottom))

  (define (rect-width rect)
    (- (point-x (end-segment (cdr rect)))
       (point-x (start-segment (cdr rect)))))

  (define (rect-height rect)
    (- (point-y (start-segment (car rect)))
       (point-y (end-segment (car rect)))))
#+END_SRC
由于矩形的面积由矩形的长和宽来决定, 所以只要抽象出 ~rect-width~ 和 ~rect-height~
过程就可以使同一个周长或者面积过程在两种不同的表示下都能工作.

* Exercise2.4
利用代换模型, 将 ~car~ 过程依次展开的结果为:
#+Name: verify
#+BEGIN_SRC scheme
  (car (cons x y))
  ((cons x y) (lambda (p q) p))
  ((lambda (m) (m x y)) (lambda (p q) p))
  ((lambda (p q) p) x y)
  x

#+END_SRC

对应的 ~cdr~ 的定义为:
#+Name: cdr.scm
#+BEGIN_SRC scheme
  (define (cdr z)
    (z (lambda (p q) q)))
#+END_SRC

* Exercise2.5
由于2的幂和3的幂不存在大于1的公约数, 所以分别找出可以整除的2的最大次幂和可以整除的3的最大次幂的结果就可以确定a和b的值.

过程定义如下:
#+Name: cons-power.scm
#+BEGIN_SRC scheme
  (define (power x n)
    (if (= n 1)
        x
        (* x (power x (- n 1)))))

  (define (cons a b)
    (* (power 2 a)
       (power 3 b)))
  (define (car z)
    (if (= 0 (remainder z 2))
        (+ 1 (car (/ z 2)))
        0))
  (define (cdr z)
    (if (= 0 (remainder z 3))
        (+ 1 (cdr (/ z 3)))
        0))
#+END_SRC

* Exercise2.6
通过代换Church计数的 ~zero~ 和 ~add-1~ 到 ~(add-1 zero)~ 中, 结果如下:
#+Name: one.scm
#+BEGIN_SRC scheme
  (add-1 zero)
  (lambda (f) (lambda (x) (f ((zero f) x))))
  (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x))))
  (lambda (f) (lambda (x) (f ((lambda (x) x) x))))
  (lambda (f) (lambda (x) (f x)))
#+END_SRC
即 ~one~ 的定义式为 ~(lambda (f) (lambda (x) (f x)))~.

再将 ~one~ 和 ~add-1~ 代入到 ~(add-1 one)~ 中, 结果如下:
#+Name: two.scm
#+BEGIN_SRC scheme
  (add-1 two)
  (lambda (f) (lambda (x) (f ((one f) x))))
  (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f x))) f) x))))
  (lambda (f) (lambda (x) (f ((lambda (x) (f x)) x))))
  (lambda (f) (lambda (x) (f (f x))))
#+END_SRC
即 ~two~ 的定义式为 ~(lambda (f) (lambda (x) (f (f x))))~.

经过上面的代换可以看出 ~add-1~ 的过程实际上相当于在原来的过程中增加了一个 ~f~ 函数的迭代调用, 而加法的定义可以看做是 ~add-n~ 的过程, 即要在原来的过程中增加 n 个 ~f~ 函数的迭代调用, 等于用 Church 计数时数n中 ~f~ 函数迭代调用的次数.

因此加法过程的一个直接定义为:
#+Name: add.scm
#+BEGIN_SRC scheme
  (define (+ a b)
    (lambda (f) (lambda (x) ((a f) ((b f) x)))))
#+END_SRC

* Exercise2.7
区间构造的完整基础定义如下:
#+Name: interval.scm
#+BEGIN_SRC scheme
  (define (make-interval a b) (cons a b))
  (define (upper-bound interval)
    (if (> (car interval) (cdr interval))
        (car interval)
        (cdr interval)))
  (define (lower-bound interval)
    (if (< (car interval) (cdr interval))
        (car interval)
        (cdr interval)))

#+END_SRC

* Exercise2.8
对于两个区间的减法来说, 最大值为减数的上界减去被减数的下界, 最小值为减数的下界减去被减数的上界. 具体定义如下:
#+Name sub-interval.scm
#+BEGIN_SRC scheme
  (define (sub-interval x y)
    (make-interval (- (upper-bound x) (lower-bound y))
                   (- (lower-bound x) (upper-bound y))))
#+END_SRC

* Exercise2.9
我们可以通过一般化的推导来证明题中的结论:

假设两个区间分别为 ~(a1, b1)~, ~(a2, b2)~, 则它们的和为 ~(a1 + a2, b1 + b2)~, 两个区间的宽度分别为 ~b1 - a1~, ~b2 - a2~, 而它们和的宽度为 ~(b1 + b2) - (a1 + a2) = (b1 - a1) + (b2 - a2)~, 即两个区间的和的宽度等于两个区间宽度的和. 减法的过程同样如此, 上述两个区间的差为 ~(a1 - b2, b1 - a2)~, 它们差的宽度为 ~(b1 - a2) - (a1 - b2) = (b1 - a1) - (b2 - a2)~, 两个区间的差的宽度等于两个区间宽度的差.

对于乘和除而言并不满足这样的关系, 例如区间 ~(1, 4)~ 和 ~(3, 9)~ 的区间宽度分别为 ~3~ 和 ~6~, 它们的乘积为 ~(3, 36)~, 乘积宽度为 ~33~, 而宽度的乘积为 ~18~; 它们的商为 ~(1/9, 4/3)~, 商宽度为 ~10/9~, 而宽度的商为 ~1/2~.

* Exercise2.10
修正 ~div-interval~ 的过程为:
#+Name: div-interval.scm
#+BEGIN_SRC scheme
  (define (div-interval x y)
    (if (>= 0 (* (upper-bound y) (lower-bound y)))
        (error "The interval contains zeros in divider")
        (mul-interval x
                      (make-interval (/ 1.0 (upper-bound y))
                                     (/ 1.0 (lower-bound y))))))
#+END_SRC

* TOVERIFY Exercise2.11
TOVERIFY: 在 ~(-, +)*(-, +)~ 的过程中用了4次乘法, 怎样才能在只用2次的情况下得出答案?

重写 ~mul-interval~ 的过程如下:
#+BEGIN_SRC scheme
  (define (mul-interval x y)
    (let ((xl (lower-bound x))
          (xu (upper-bound x))
          (yl (lower-bound y))
          (yu (upper-bound y)))
      (cond ((< xu 0)
             (cond ((< yu 0)              ;1. (-, -) * (-, -)
                    (make-interval (* xu yu) (* xl yl)))
                   ((< yl 0)              ;2. (-, -) * (-, +)
                    (make-interval (* xl yu) (* xl yl)))
                   (else                  ;3. (-, -) * (+, +)
                    (make-interval (* xl yu) (* xu yl)))))
            ((< xl 0)
             (cond ((< yu 0)              ;4. (-, +) * (-, -)
                    (make-interval (* xu yl) (* xl yl)))
                   ((< yl 0)              ;5. (-, +) * (-, +)
                    (make-interval (min (* xl yu) (* xu yl))
                                   (max (* xl yl) (* xu yu))))
                   (else                  ;6. (-, +) * (+, +)
                    (make-interval (* xl yu) (* xu yu)))))
            (else
             (cond ((< yu 0)              ;7. (+, +) * (-, -)
                    (make-interval (* xu yl) (* xl yu)))
                   ((< yl 0)              ;8. (+, +) * (-, +)
                    (make-interval (* xu yl) (* xu yu)))
                   (else                  ;9. (+, +) * (+, +)
                    (make-interval (* xl yl) (* xu yu)))))))
#+END_SRC

* Exercise2.12
~make-center-percent~ 的过程定义如下:
#+Name: center-percent.scm
#+BEGIN_SRC scheme
  (define (make-center-percent c p)
    (make-interval (- c (* c p))
                   (+ c (* c p))))
  (define (center i)
    (/ (+ (lower-bound i) (upper-bound i)) 2))
  (define (percent i)
    (/ (/ (- (upper-bound i) (lower-bound i)) 2)
       (/ (+ (upper-bound i) (lower-bound i)) 2)))
#+END_SRC

* Exercise2.13
设两个区间分别为 ~(x - ax, x + ax)~, ~(y - by, y + by)~, 它们的乘积宽度为
~(xy + axy + bxy + abxy) - (xy - axy - bxy + abxy) = 2(a + b)xy~, 当百分比很小时,
乘积本身可看做 ~(xy - (a + b)xy, xy + (a + b)xy)~, 所以两个被乘区间的百分误差可
看做各自百分误差之和.

* Exercise2.14
1. 通过程序验证, 得到的输出如下:
   #+Name: Output
   #+BEGIN_SRC
     scheme@(guile-user)> (define r1 (make-interval 2 4))
     scheme@(guile-user)> (define r2 (make-interval 3 8))
     scheme@(guile-user)> (par1 r1 r2)
     $1 = (0.5 . 6.4)
     scheme@(guile-user)> (par2 r1 r2)
     $2 = (1.2000000000000002 . 2.6666666666666665)

   #+END_SRC
   可以看到两种方式所得到的结果完全不同. ~par2~ 过程得到的结果区间要更小一点.

2. 按照中心-百分比形式进行除法检验的输出为:
   #+Name: Output
   #+BEGIN_SRC
     scheme@(guile-user)> (define A (make-interval 60 62))
     scheme@(guile-user)> (define B (make-interval 30 33))
     scheme@(guile-user)> (div-interval A A)
     $1 = (0.967741935483871 . 1.0333333333333332)
     scheme@(guile-user)> (div-interval A B)
     $2 = (1.8181818181818183 . 2.0666666666666664)
     scheme@(guile-user)> (define A (make-center-percent 60 0.01))
     scheme@(guile-user)> (define B (make-center-percent 30 0.02))
     scheme@(guile-user)> (define r1 (div-interval A A))
     scheme@(guile-user)> (center r1)
     $3 = 1.000200020002
     scheme@(guile-user)> (percent r1)
     $4 = 0.019998000199980024
     scheme@(guile-user)> (define r2 (div-interval A B))
     scheme@(guile-user)> (center r2)
     $5 = 2.001200480192077
     scheme@(guile-user)> (percent r2)
     $6 = 0.02999400119976012

   #+END_SRC
   可以看出两个相同区间作除法并没有得到理论上的标准单位元. 商的误差百分比大致相
   当于被除数和除数的误差百分比之和, 即所做运算使误差区间增大.

* Exercise2.15
在 ~par1~ 过程中, 在进行除法计算时除数和被除数之间存在相关关系, 但是在计算时依然
是按照无关变量的方式进行计算, 因此范围被"虚拟"地扩大了. 而在 ~par2~ 不存在这样的
情况. 因此 ~par2~ 是比 ~par1~ "更好的" 程序.

* TODO Exercise2.16
TODO: 要想使得等价的代数表达式得到的结果相同, 需要考虑相关变量在分步计算中所带来的影响.

* Exercise2.17
过程 ~last-pair~ 的定义如下:
#+Name: last-pair.scm
#+BEGIN_SRC scheme
  (define (last-pair list)
    (if (null? (cdr list))
        list
        (last-pair (cdr list))))
#+END_SRC

* Exercise2.18
过程 ~reverse~ 的定义如下:
#+Name reverse.scm
#+BEGIN_SRC scheme
  (define (reverse list)
    (if (null? list)
        '()
        (append (reverse (cdr list))
              (cons (car list) '()))))
#+END_SRC

* Exercise2.19
兑换零钱方式计数的改进版本定义如下:
#+Name: cc.scm
#+BEGIN_SRC scheme
  (define us-coins (list 50 25 10 5 1))
  (define uk-coins (list 100 50 20 10 5 2 1 0.5))

  (define (cc amount coin-values)
    (cond ((= amount 0) 1)
          ((or (< amount 0) (no-more? coin-values)) 0)
          (else
           (+ (cc amount
                  (except-first-denomination coin-values))
              (cc (- amount
                     (first-denomination coin-values))
                  coin-values)))))

  (define (no-more? coin-values)
    (null? coin-values))

  (define (except-first-denomination coin-values)
    (cdr coin-values))

  (define (first-denomination coin-values)
    (car coin-values))
#+END_SRC
表 ~coin-values~ 的排列顺序不会影响cc给出的答案, 因为
~except-first-denomination~ 和 ~first-denomination~ 的过程包含了所有可能的情况,
即任何一种可能的情况要么出现在第一种情况中, 要么出现在第二种情况中, 而与顺序无关.

* Exercise2.20
过程 ~same-parity~ 的定义如下:
#+Name: same-parity.scm
#+BEGIN_SRC scheme
  (define (same-parity x . list)
    (let ((same? (if (even? x)
                     even?
                     odd?)))
      (define (parity list)
        (cond ((null? list) '())
              ((same? (car list))
               (cons (car list) (parity (cdr list))))
              (else (parity (cdr list)))))
      (cons x (parity list))))
#+END_SRC

* Exercise2.21
过程 ~square-list~ 的两个定义的补全如下:
#+Name: square-list.scm
#+BEGIN_SRC scheme
  (define (square-list items)
    (if (null? items)
        '()
        (cons (square (car items))
              (square-list (cdr items)))))

  (define (square-list items)
    (map (lambda (x) (square x))
         items))
#+END_SRC

* Exercise2.22
1. 按第一种方式产生出的结果中, 因为items中先被取出(car)的元素会先被加入结果的表中, 这样原表中的元素在新表中会在与之对称的位置, 即元素的顺序正好相反.
2. 按照第二种方式, 说得结果中每个cons的第二个元素都指向一个实际值, 与表定义所要求的正好相反.

* Exercise2.23
过程 ~for-each~ 的一个实现如下:
#+Name: for-each.scm
#+BEGIN_SRC scheme
  (define (for-each f items)
    (cond ((null? items) #t)
          (else
           (f (car items))
           (for-each f (cdr items)))))
#+END_SRC

* Exercise2.24
解释器打印的结果为 ~(1 (2 (3 4)))~.
[[./images/224.png]]

* Exercise2.25
从下面各表中取出7的 ~car~ 和 ~cdr~ 的组合为:
#+Name: Solutions
#+BEGIN_SRC scheme
  ;; (1 3 (5 7) 9)
  (define x '(1 3 (5 7) 9))
  (car (cdr (car (cdr (cdr x)))))

  ;; ((7))
  (define y '((7)))
  (car (car y))

  ;; (1 (2 (3 (4 (5 (6 7))))))
  (define z '(1 (2 (3 (4 (5 (6 7)))))))
  (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr z))))))))))))
#+END_SRC

* Exercise2.26
各个表达式的打印结果如下:
#+Name: Solutions
#+BEGIN_SRC scheme
  ;; x: (1 2 3) y: (4 5 6)

  ;; (append x y)
  (1 2 3 4 5 6)

  ;; (cons x y)
  ((1 2 3) 4 5 6)

  ;; (list x y)
  ((1 2 3) (4 5 6))
#+END_SRC

* Exercise2.27
过程 ~deep-reverse~ 的定义如下:
#+Name: deep-reverse.scm
#+BEGIN_SRC scheme
  (define (deep-reverse tree)
    (cond ((null? tree) '())
          ((not (pair? tree)) tree)
          (else (append (deep-reverse (cdr tree))
                        (cons (deep-reverse (car tree))
                              '())))))
#+END_SRC

* Exercise2.28
过程 ~fringe~ 的定义如下:
#+Name: fringe.scm
#+BEGIN_SRC scheme
  (define (fringe tree)
    (cond ((null? tree) '())
          ((not (pair? (car tree)))
           (cons (car tree) (fringe (cdr tree))))
          (else (append (fringe (car tree))
                        (fringe (cdr tree))))))
#+END_SRC

* Exercise2.29
1. ~branch~ 的一些简单操作定义如下:
   #+Name: branch.scm
   #+BEGIN_SRC scheme
     (define (make-mobile left right)
       (list left right))

     (define (make-branch length structure)
       (list length structure))

     (define (left-branch mobile)
       (car mobile))

     (define (right-branch mobile)
       (car (cdr mobile)))

     (define (branch-length branch)
       (car branch))

     (define (branch-structure branch)
       (car (cdr branch)))
   #+END_SRC
2. 过程 ~total-weight~ 的定义如下:
   #+Name: total-weight.scm
   #+BEGIN_SRC scheme
     (define (total-weight mobile)
       (cond ((null? mobile) 0)
             ((not (pair? mobile)) mobile)
             (else
              (+ (total-weight
                  (branch-structure (left-branch mobile)))
                 (total-weight
                  (branch-structure (right-branch mobile)))))))
   #+END_SRC
3. 检查一个二叉活动体是否平衡的过程 ~balance?~ 的定义如下:
   #+Name: balance?.scm
   #+BEGIN_SRC scheme
     (define (balance? mobile)
       (if (or (null? mobile) (not (pair? mobile)))
           #t
           (and (= (* (branch-length (left-branch mobile))
                      (total-weight
                       (branch-structure (left-branch mobile))))
                   (* (branch-length (right-branch mobile))
                      (total-weight
                       (branch-structure (right-branch mobile)))))
                (balance? (branch-structure (left-branch mobile)))
                (balance? (branch-structure (right-branch mobile))))))
   #+END_SRC
4. 如果改变活动体的构造方式, 要保持程序仍旧可用, 只需修改对应的选择函数即可:
   #+Name: branch-modified.scm
   #+BEGIN_SRC scheme
     (define (make-mobile left right)
       (cons left right))

     (define (make-branch length structure)
       (cons length structure))

     (define (left-branch mobile)
       (car mobile))

     (define (right-branch mobile)
       (cdr mobile))

     (define (branch-length branch)
       (car branch))

     (define (branch-structure branch)
       (cdr branch))
   #+END_SRC

* Exercise2.30
使用递归定义 ~square-tree~ 的过程如下:
#+Name: square-tree.scm
#+BEGIN_SRC scheme
  (define (square-tree tree)
    (cond ((null? tree) '())
          ((not (pair? tree)) (square tree))
          (else (cons (square-tree (car tree))
                      (square-tree (cdr tree))))))
#+END_SRC
使用 ~map~ 定义 ~square-tree~ 的过程如下:
#+Name: square-tree.scm
#+BEGIN_SRC scheme
  (define (square-tree tree)
    (map (lambda (subtree)
           (if (pair? subtree)
               (square-tree subtree)
               (square subtree)))
         tree))
#+END_SRC

* Exercise2.31
利用 ~map~ 做进一步的抽象过程 ~tree-map~, 过程定义如下:
#+Name: tree-map.scm
#+BEGIN_SRC scheme
  (define (tree-map func tree)
    (map (lambda (subtree)
           (if (pair? subtree)
               (tree-map func subtree)
               (func subtree)))
         tree))
#+END_SRC

* Exercise2.32
过程 ~subsets~ 的完整定义如下:
#+Name: subsets.scm
#+BEGIN_SRC scheme
  (define (subsets s)
    (if (null? s)
        (list '())
        (let ((rest (subsets (cdr s))))
          (append rest (map (lambda (x) (cons (car s) x)) rest)))))
#+END_SRC
一个集合的所有子集可以看作是包含第一个元素的子集和不包含第一个元素的子集的总和.

* Exercise2.33
完整的表达式如下:
#+Name: Solutions
#+BEGIN_SRC scheme
  ;; 1)
  (define (map p sequence)
    (accumulate (lambda (x y) (cons (p x) y)) '() sequence))

  ;; 2)
  (define (append seq1 seq2)
    (accumulate cons seq2 seq1))

  ;; 3)
  (define (length sequence)
    (accumulate (lambda (x y) (+ 1 y)) 0 sequence))
#+END_SRC

* Exercise2.34
利用Horner规则求多项式值的完整过程定义如下:
#+Name: horner-eval.scm
#+BEGIN_SRC scheme
  (define (horner-eval x coefficient-sequence)
    (accumulate (lambda (this-coeff higher-terms)
                  (+ this-coeff (* x higher-terms)))
                0
                coefficient-sequence))
#+END_SRC

* Exercise2.35
用累积的形式重新定义 ~count-leaves~ 的过程如下:
#+Name: count-leaves.scm
#+BEGIN_SRC scheme
  (define (count-leaves t)
    (accumulate + 0
                (map (lambda (x) 1) (fringe t))))
#+END_SRC

* Exercise2.36
完整的 ~accumulate-n~ 定义如下:
#+Name: accumulate-n.scm
#+BEGIN_SRC scheme
  (define (accumulate-n op init seqs)
    (if (null? (car seqs))
        '()
        (cons (accumulate op init (map car seqs))
              (accumulate-n op init (map cdr seqs)))))
#+END_SRC

* Exercise2.37
矩阵运算基本操作的完整定义如下:
#+Name: matrix-op.scm
#+BEGIN_SRC scheme
  (define (dot-product v w)
    (accumulate + 0 (map * v w)))

  (define (matrix-*-vector m v)
    (map (lambda (x) (dot-product x v)) m))

  (define (transpose mat)
    (accumulate-n cons '() mat))

  (define (matrix-*-matrix m n)
    (let ((cols (transpose n)))
      (map (lambda (x) (matrix-*-vector cols x)) m)))
#+END_SRC

* Exercise2.38
下列各式的值依次为:
#+Name: Solutions
#+BEGIN_SRC scheme
  ;; (fold-right / 1 (list 1 2 3))
  3/2

  ;; (fold-left / 1 (list 1 2 3))
  1/6

  ;; (fold-right list nil (list 1 2 3))
  (1 (2 (3 ())))

  ;; (fold-left list nil (list 1 2 3))
  (((() 1) 2) 3)
#+END_SRC

* Exercise2.39
分别基于 ~fold-right~ 和 ~fold-left~ 定义 ~reverse~ 的过程如下:
#+Name: reverse.scm
#+BEGIN_SRC scheme
  (define (reverse sequence)
    (fold-right (lambda (x y) (append y (list x))) '() sequence))

  (define (reverse sequence)
    (fold-left (lambda (x y) (cons y x)) '() sequence))
#+END_SRC

* Exercise2.40
过程 ~unique-pairs~ 的定义如下:
#+Name: unique-pairs.scm
#+BEGIN_SRC scheme
  (define (unique-pairs n)
    (flatmap (lambda (i)
               (map (lambda (j) (list i j))
                    (enumerate-interval 1 (- i 1))))
             (enumerate-interval 1 n)))

  (define (enumerate-interval beg end)
    (cond ((> beg end) '())
          ((= beg end) (list end))
          (else (cons beg (enumerate-interval (+ beg 1) end)))))
#+END_SRC
用 ~unique-pairs~ 简化 ~prime-sum-pairs~ 的定义如下:
#+Name: prime-sum-pairs.scm
#+BEGIN_SRC scheme
  (define (prime-sum-pairs n)
    (map make-pair-sum
         (filter prime-sum? (unique-pairs n))))

  (define (prime-sum? pair)
    (prime? (+ car pair) (cadr pair)))

  (define (make-pair-sum pair)
    (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
#+END_SRC

* Exercise2.41
过程 ~fixed-sum-tuples~ 的定义如下:
#+Name: fixed-sum-tuples.scm
#+BEGIN_SRC scheme
  (define (fixed-sum-tuples n s)
    (filter (lambda (t)
              (= s (+ (car t) (cadr t) (caddr t))))
            (flatmap (lambda (i)
                       (flatmap (lambda (j)
                                  (map (lambda (k) (list i j k))
                                       (remove j
                                               (remove i (enumerate-interval 1 n)))))
                                (remove i (enumerate-interval 1 n))))
                     (enumerate-interval 1 n))))

#+END_SRC

* Exercise2.42
解决八皇后问题的完整过程定义如下:
#+Name: queens.scm
#+BEGIN_SRC scheme
  (define (queens board-size)
    (define (queen-cols k)
      (if (= k 0)
          (list empty-board)
          (filter
           (lambda (positions) (safe? k positions))
           (flatmap
            (lambda (rest-of-queens)
              (map (lambda (new-row)
                     (adjoin-position new-row k rest-of-queens))
                   (enumerate-interval 1 board-size)))
            (queen-cols (- k 1))))))
    (queen-cols board-size))

  (define (adjoin-position new-row k rest-queens)
    (cons new-row rest-queens))

  (define empty-board '())

  (define (safe? k positions)
    (define (iter cur i rest)
      (if (= i k)
          #t
          (and (not (= cur (car rest)))
               (not (= (- cur i) (car rest)))
               (not (= (+ cur i) (car rest)))
               (iter cur (+ i 1) (cdr rest)))))
    (iter (car positions) 1 (cdr positions)))
#+END_SRC

* Exercise2.43
假设执行一次 ~adjoin-position~ 的时间为单位时间, 当我们采用Exercise2.42中的过程
时, 有 ~T(n) = T(n - 1) + a(n - 1) * k~, 其中 ~T(n)~ 表示 ~k = n~ 的运行时间,
~a(n)~ 表示 ~(queen-cols n)~ 的长度. 当交换嵌套映射的顺序后, 运行时间 ~T'(n) ~
s * T'(n - 1) + a(n - 1) * k~, 其中 ~s~ 代表棋盘的大小, 当用后者去解决八皇后问题
时, 时间消耗大致为 ~8^8 * T~.

* Exercise2.44`
过程 ~up-split~ 定义如下:
#+Name: up-split.scm
#+BEGIN_SRC scheme
  (define (up-split painter n)
    (if (= n 0)
        painter
        (let ((smaller (up-split painter (- n 1))))
          (below painter (beside smaller smaller)))))
#+END_SRC

* Exercise2.45
过程 ~split~ 的定义如下:
#+Name: split.scm
#+BEGIN_SRC scheme
  (define (split p1 p2)
    (define (inner painter n)
      (if (= n 0)
          painter
          (let ((smaller (inner painter (- n 1))))
            (p1 (p2 smaller smaller))))))
#+END_SRC

* Exercise2.46
关于 ~vect~ 的一系列过程定义如下:
#+Name: vect.scm
#+BEGIN_SRC scheme
  (define (make-vect x y)
    (cons x y))

  (define (xcor-vect v)
    (car v))

  (define (ycor-vect v)
    (cdr v))

  (define (add-vect v1 v2)
    (make-vect (+ (xcor-vect v1) (xcor-vect v2))
               (+ (ycor-vect v1) (ycor-vect v2))))

  (define (sub-vect v1 v2)
    (make-vect (- (xcor-vect v1) (xcor-vect v2))
               (- (ycor-vect v1) (ycor-vect v2))))

  (define (scale-vect s v)
    (make-vect (* s (xcor-vect v))
               (* s (ycor-vect v))))
#+END_SRC

* Exercise2.47
为第一种 ~make-frame~ 实现选择函数为:
#+Name: make-frame.scm
#+BEGIN_SRC scheme
  (define (make-frame origin edge1 edge2)
    (list origin edge1 edge2))

  (define (origin-frame frame)
    (car frame))

  (define (edge1-frame frame)
    (cadr frame))

  (define (edge2-frame frame)
    (caddr frame))
#+END_SRC

第二种 ~make-frame~ 的选择函数实现为:
#+Name: make-frame.scm
#+BEGIN_SRC scheme
  (define (make-frame origin edge1 edge2)
    (cons origin (cons edge1 edge2)))

  (define (origin-frame frame)
    (car frame))

  (define (edge1-frame frame)
    (cadr frame))

  (define (edge2-frame frame)
    (cddr frame))
#+END_SRC

* Exercise2.48
基于 ~vect~ 定义 ~segment~ 的相关过程如下:
#+Name: segment.scm
#+BEGIN_SRC scheme
  (define (make-segment v1 v2)
    (cons v1 v2))

  (define (start-segment s)
    (car s))

  (define (end-segment s)
    (cdr s))
#+END_SRC

* Exercise2.49
利用 ~segments->painter~ 分别定义如下的基本画家:
#+Name: painter.scm
#+BEGIN_SRC scheme
  ;; a) border-painter
  (define border-painter
    (segments->painter
     (list (make-segment (make-vect 0 0) (make-vect 0 1))
           (make-segment (make-vect 0 1) (make-vect 1 1))
           (make-segment (make-vect 1 1) (make-vect 1 0))
           (make-segment (make-vect 1 0) (make-vect 0 0)))))

  ;; b) X-painter
  (define X-painter
    (segments->painter
     (list (make-segment (make-vect 0 0) (make-vect 1 1))
           (make-segment (make-vect 1 0) (make-vect 0 1)))))

  ;; c) diamond-painter
  (define diamond-painter
    (segments->painter
     (list (make-segment (make-vect 0.5 0) (make-vect 1 0.5))
           (make-segment (make-vect 1 0.5) (make-vect 0.5 1))
           (make-segment (make-vect 0.5 1) (make-vect 0 0.5))
           (make-segment (make-vect 0 0.5) (make-vect 0.5 0)))))

  ;; d) wave
  (define wave
    (segments->painter
     (list (make-segment (make-vect 0.4 0.0) (make-vect 0.5 0.33))
           (make-segment (make-vect 0.5 0.33) (make-vect 0.6 0.0))
           (make-segment (make-vect 0.75 0.0) (make-vect 0.6 0.45))
           (make-segment (make-vect 0.6 0.45) (make-vect 0.99 0.2))
           (make-segment (make-vect 0.99 0.4) (make-vect 0.8 0.65))
           (make-segment (make-vect 0.8 0.65) (make-vect 0.6 0.65))
           (make-segment (make-vect 0.6 0.65) (make-vect 0.65 0.8))
           (make-segment (make-vect 0.65 0.8) (make-vect 0.6 0.99))
           (make-segment (make-vect 0.4 0.99) (make-vect 0.35 0.8))
           (make-segment (make-vect 0.35 0.8) (make-vect 0.4 0.65))
           (make-segment (make-vect 0.4 0.65) (make-vect 0.33 0.65))
           (make-segment (make-vect 0.33 0.65) (make-vect 0.1 0.6))
           (make-segment (make-vect 0.1 0.6) (make-vect 0.0 0.8))
           (make-segment (make-vect 0.0 0.6) (make-vect 0.1 0.4))
           (make-segment (make-vect 0.1 0.4) (make-vect 0.3 0.6))
           (make-segment (make-vect 0.3 0.6) (make-vect 0.33 0.5))
           (make-segment (make-vect 0.33 0.5) (make-vect 0.25 0.0)))))

#+END_SRC

* Exercise2.50
过程 ~flip-horiz~ 的定义如下:
#+Name: flip-horiz.scm
#+BEGIN_SRC scheme
  (define (flip-horiz painter)
    (transform-painter painter
                       (make-vect 1.0 0.0)
                       (make-vect 1.0 1.0)
                       (make-vect 0.0 0.0)))

  ;; 180 degree rotate
  (define (rotate180 painter)
    (transform-painter painter
                       (make-vect 1.0 1.0)
                       (make-vect 0.0 1.0)
                       (make-vect 1.0 0.0)))

  ;; 270 degree rotate
  (define (rotate270 painter)
    (transform-painter painter
                       (make-vect 0.0 1.0)
                       (make-vect 0.0 0.0)
                       (make-vect 1.0 1.0)))
#+END_SRC

* Exercise2.51
通过两种不同方式定义 ~below~ 的过程如下:
#+Name: below.scm
#+BEGIN_SRC scheme
  ;; 1
  (define (below painter1 painter2)
    (let ((split-point (make-vect 0.0 0.5)))
      (let ((paint-up
             (transform-painter painter1
                                (make-vect 0.0 0.0)
                                (make-vect 1.0 0.0)
                                split-point))
             (paint-down
              (transform-painter painter2
                               split-point
                               (make-vect 1.0 0.5)
                               (make-vect 0.0 1.0))))
        (lambda (frame)
          (paint-up frame)
          (paint-down frame)))))

  ;; 2
  (define (below painter1 painter2)
    (rotate90 (beside (rotate270 painter1)
                      (rotate270 painter2))))
#+END_SRC

* TODO Exercise2.52
* Exercise2.53
下列各个表达式的值分别为:
#+Name: Solutions
#+BEGIN_SRC scheme
  ;; (list 'a 'b 'c)
  (a b c)

  ;; (list (list 'george))
  ((george))

  ;; (cdr '((x1 x2) (y1 y2)))
  ((y1 y2))

  ;; (cadr '((x1 x2) (y1 y2)))
  (y1 y2)

  ;; (pair? (car '(a short list)))
  #f

  ;; (memq 'red '((red shoes) (blue socks)))
  #f

  ;; (memq 'red '(red shoes blue socks))
  (red shoes blue socks)
#+END_SRC

* Exercise2.54
过程 ~equal?~ 的定义如下:
#+Name: equal?.scm
#+BEGIN_SRC scheme
  (define (equal? x y)
    (cond ((and (null? x) (null? y)) #t)
          ((and (pair? (car x)) (pair? (car y)))
           (and (equal? (car x) (car y))
                (equal? (cdr x) (cdr y))))
          (else (and (eq? (car x) (car y))
                (equal? (cdr x) (cdr y))))))
#+END_SRC

* Exercise2.55
表达式 ~(car ''abracadabra)~ 等价于 ~(car (quote (quote abracadabra)))~, 即对列
表 ~(quote abracadabra)~ 做 ~car~ 操作, 因此返回结果为 ~quote~.

* Exercise2.56
添加幂函数后的求导过程定义如下:
#+Name: exponentiation.scm
#+BEGIN_SRC scheme
  (define (deriv exp var)
    (cond ((number? exp) 0)
          ((variable? exp)
           (if (same-variable? exp var) 1 0))
          ((sum? exp)
           (make-sum (deriv (addend exp) var)
                     (deriv (augend exp) var)))
          ((product? exp)
           (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
          ((exponentiation? exp)
           (make-product
            (make-product (exponent exp)
                          (make-exponentiation (base exp) (- (exponent exp) 1)))
            (deriv (base exp) var)))
          (else
           (error "unkown expression type -- DERIV" exp))))

  (define (exponentiation? x)
    (and (pair? x) (eq? (car x) '^) (number? (caddr x))))
  (define (make-exponentiation base exp)
    (cond ((=number? exp 0) 1)
          ((=number? exp 1) base)
          ((and (number? base) (number? exp)) (expt base exp))
          (else (list '^ base exp))))
  (define (base e) (cadr e))
  (define (exponent e) (caddr e))
#+END_SRC

* Exercise2.57
经过改进的能处理任意项的和与乘积的求导程序定义如下:
#+Name: deriv-ex.scm
#+BEGIN_SRC scheme
  (define (addend s) (cadr s))
  ;;(define (augend s) (caddr s))
  (define (augend s)
    (if (null? (cdddr s))
        (caddr s)
        (cons '+ (cddr s))))

  (define (addend s) (cadr s))
  ;;(define (augend s) (caddr s))
  (define (augend s)
    (if (null? (cdddr s))
        (caddr s)
        (cons '+ (cddr s))))
#+END_SRC

* Exercise2.58
1. 采用中缀表达式定义谓词, 选择函数和构造函数的过程定义如下:
   #+Name: infix-deriv.scm
   #+BEGIN_SRC scheme
     (define (make-sum a1 a2)
       (cond ((=number? a1 0) a2)
             ((=number? a2 0) a1)
             ((and (number? a1) (number? a2)) (+ a1 a2))
             (else (list a1 '+ a2))))
     (define (make-product m1 m2)
       (cond ((or (=number? m1 0) (=number? m2 0)) 0)
             ((=number? m1 1) m2)
             ((=number? m2 1) m1)
             ((and (number? m1) (number? m2)) (* m1 m2))
             (else (list m1 '* m2))))

     (define (sum? s)
       (and (pair? s) (eq? (cadr s) '+)))

     (define (product? p)
       (and (pair? p) (eq? (cadr p) '*)))

     (define (addend s) (car s))
     (define (augend s) (caddr s))

     (define (multiplier p) (car p))
     (define (multiplicand p) (caddr p))
   #+END_SRC
2. 采用标准代数写法(中缀)的表示, 选择函数和构造函数的过程定义如下：
   #+NAME: infix-deriv-std.scm
   #+BEGIN_SRC scheme
     (define (make-sum a1 a2)
       (cond ((=number? a1 0) a2)
             ((=number? a2 0) a1)
             ((and (number? a1) (number? a2)) (+ a1 a2))
             (else (list a1 '+ a2))))

     (define (make-product m1 m2)
       (cond ((or (=number? m1 0) (=number? m2 0)) 0)
             ((=number? m1 1) m2)
             ((=number? m2 1) m1)
             ((and (number? m1) (number? m2)) (* m1 m2))
             (else (list m1 '* m2))))

     (define (pare exp)
       (if (and (pair? exp) (null? (cdr exp)))
           (pare (car exp))
           exp))
     (define (sep-as-symbol exp s)
       (define (sep-iter l-exp r-exp s)
         (cond ((null? r-exp) '())
               ((eq? s (car r-exp))
                (cons (pare l-exp) (pare (cdr r-exp))))
               (else (sep-iter (append l-exp (list (car r-exp)))
                               (cdr r-exp)
                               s))))
       (sep-iter '() exp s))

     (define (sum? exp)
       (and (pair? exp)
            (not (null? (sep-as-symbol exp '+)))))
     (define (addend exp)
       (car (sep-as-symbol exp '+)))
     (define (augend exp)
       (cdr (sep-as-symbol exp '+)))

     (define (product? exp)
       (and (pair? exp)
            (null? (sep-as-symbol exp '+))
            (not (null? (sep-as-symbol exp '*)))))
     (define (multiplier exp)
       (car (sep-as-symbol exp '*)))
     (define (multiplicand exp)
       (cdr (sep-as-symbol exp '*)))

   #+END_SRC

* Exercise2.59
采用未排序的集合实现 ~union-set~ 的定义如下:
#+Name: union-set.scm
#+BEGIN_SRC scheme
  (define (union-set set1 set2)
    (cond ((null? set1) set2)
          ((null? set2) set1)
          ((not (element-of-set? (car set1) set2))
           (cons (car set1) set2))
          (else (union-set (cdr set1) set2))))
#+END_SRC

* Exercise2.60
允许重复的集合操作定义如下:
#+Name: multi-set.scm
#+BEGIN_SRC scheme
  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((equal? x (car set)) #t)
          (else (element-of-set? x (cdr set)))))

  (define (adjoin-set x set)
    (cons x set))

  (define (union-set set1 set2)
    (append set1 set2))

  (define (intersection-set set1 set2)
    (cond ((or (null? set1) (null? set2)) '())
          ((element-of-set? (car set1) set2)
           (cons (car set1)
                 (intersection-set (cdr set1) set2)))
          (else (intersection-set (cdr set1) set2))))
#+END_SRC
其中 ~element-of-set?~ 和 ~intersection-set~ 操作依然需要遍历表, 由于允许元素重
复, 表长度相应增大, 所以这两项操作效率变低, 而 ~adjoin-set~ 和 ~union-set~ 操作
仅需常数时间即可完成. 当具体应用中操作大多数为添加和并操作时更倾向于使用该种表示.

* Exercise2.61
采用排序表示时 ~adjoin-set~ 的实现如下：
#+NAME: adjoin-set.scm
#+BEGIN_SRC scheme
  (define (adjoin-set x set)
    (define (adjoin-set-iter x l-set r-set)
      (if (or (null? r-set)
              (< x (car r-set)))
          (append l-set (cons x r-set))
          (adjoin-set-iter x
                           (append l-set (list (car r-set)))
                           (cdr r-set))))
    (adjoin-set-iter x '() set))
#+END_SRC
程序运行时只需找到比当前插入元素大的元素的位置。平均而言，我们可以期望需要检查表
中的一半元素，所需的平均步骤大约是 n / 2.

* Exercise2.62
在集合的排序表示上的一个\Theta(n)的实现如下:
#+Name: union-set.csm
#+BEGIN_SRC scheme
  (define (union-set set1 set2)
    (cond ((null? set1) set2)
          ((null? set2) set1)
          (else (let ((x1 (car set1)) (x2 (car set2)))
                  (cond ((= x1 x2)
                         (cons x1
                               (union-set (cdr set1)
                                          (cdr set2))))
                        ((< x1 x2)
                         (cons x1
                               (union-set (cdr set1) set2)))
                        ((< x2 x1)
                         (cons x2
                               (union-set set1 (cdr set2)))))))))
#+END_SRC

* Exercise2.63
1. 这两个过程都产生树的中序遍历结果.
2. 两个过程做了相同数量的 ~cons~ 操作, 具有同样量级的增长速度.

* Exercise2.64
1. ~partial-tree~ 在每次递归时将所有结点分为两半, 这样保证了对于生成树的任意一
   个结点, 其左子树与右子树结点数差不超过1, 因此该生成树是平衡二叉树. 将
   ~paritial-tree~ 用于表 ~(1 3 5 7 9)~ 产生的树为:
   #+Name: Output
   #+BEGIN_SRC scheme
     (5 (1 ()
           (3 ()
              ()))
        (9 (7 ()
              ())
           (11 ()
               ())))
   #+END_SRC
2. 由程序的递归关系可得 ~T(n) = 2 * T(n / 2) + \Theta(1)~, 所以转换n个元素的表
   所需的步数以 \Theta(n) 为量级.

* Exercise2.65
首先通过 ~tree->list~ 将两个集合由二叉树表示转换为有序表，然后利用之前有序表的过程做 ~union-set~ 和 ~intersection-set~ 操作，然后再通过 ~list->tree~ 将有序表转换为二叉树，这三个步骤每一步的时间复杂度都是 \Theta(n)，所以总的时间复杂度也为 \Theta(n)。

* Exercise2.66
对于采用二叉树实现的集合, 定义 ~lookup~ 过程如下:
#+Name: lookup.scm
#+BEGIN_SRC scheme
  (define (lookup given-key set-of-records)
    (cond ((null? set-of-records) #f)
          ((= given-key (key (car set-of-records)))
           (car set-of-records))
          ((< given-key (key (car set-of-records)))
           (lookup given-key (left-branch set-of-records)))
          (else (lookup given-key (right-branch set-of-records)))))
#+END_SRC

* Exercise2.67
定义样例编码树和样例消息如下:
#+Name: sample.scm
#+BEGIN_SRC scheme
  (define sample-tree
    (make-code-tree (make-leaf 'A 4)
                    (make-code-tree
                     (make-leaf 'B 2)
                     (make-code-tree (make-leaf 'D 1)
                                     (make-leaf 'C 1)))))

  (define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
#+END_SRC
使用过程 ~decode~ 得到的编码结果为:
#+Name: Output
#+BEGIN_SRC
  scheme@(guile-user)> (decode sample-message sample-tree)
  $1 = (A D A B B C A)

#+END_SRC

* Exercise2.68
过程 ~encode~ 的定义如下:
#+Name: encode.scm
#+BEGIN_SRC scheme
  (define (encode message tree)
    (if (null? message)
        '()
        (append (encode-symbol (car message) tree)
                (encode (cdr message) tree))))

  (define (encode-symbol symbol tree)
    (cond ((leaf? tree) '())
          ((contains? symbol (symbols (left-branch tree)))
           (cons 0 (encode-symbol symbol (left-branch tree))))
          ((contains? symbol (symbols (right-branch tree)))
           (cons 1 (encode-symbol symbol (right-branch tree))))
          (else (error "unknow symbol" symbol))))

  (define (contains? e list)
    (cond ((null? list) #f)
          ((eq? e (car list)) #t)
          (else (contains? e (cdr list)))))
#+END_SRC

* Exercise2.69
根据符号-频度对偶表生成Huffman编码树的过程实现如下:
#+Name: generate-huffman-tree.scm
#+BEGIN_SRC scheme
  (define (generate-huffman-tree pairs)
    (successive-merge (make-leaf-set pairs)))

  (define (successive-merge set)
    (cond ((null? set) '())
          ((null? (cdr set)) (car set))
          (else (successive-merge
                 (adjoin-set (make-code-tree (car set) (cadr set))
                             (cddr set))))))
#+END_SRC

* Exercise2.70
定义8个符号的字母频度表和文本消息:
#+Name: Exercise
#+BEGIN_SRC scheme
  (define pairs
    '((a 2) (na 16) (boom 1) (sha 3) (get 2) (yip 9) (job 2) (wah 1)))

  (define message
    '(get a job sha na na na na na na na na get a job sha na na na na na na
          na na wah yip yip yip yip yip yip yip yip yip sha boom))
#+END_SRC
利用huffman编码过程生成的编码为:
#+Name: Output
#+BEGIN_SRC
  scheme@(guile-user)> (encode message (generate-huffman-tree pairs))
  $1 = (1 1 1 1 1 1 1 0 0 1 1 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 0 1 1 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0 1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 0 1 1 0 1 1)

#+END_SRC
这一编码一共使用了88个二进制位. 若采用定长编码, 每个符号需要3个二进制位, 完成这
个歌曲最少需要 ~36 * 4 = 144~ 个二进制位.

* Exercise2.71
对于这样的编码, 出现最频繁的符号要用 2 个二进制位表示, 最不频繁的符号要用 n 个二进制位表示.

* Exercise2.72
当符号的相对频率满足如2.71中所描述的规则时, 编码最频繁的符号所需的步数的增长速率为 \Theta(1), 最不频繁的符号所需步数的增长速率为 \Theta(n^{2}).

* Exercise2.73
1. 数据导向的求导程序根据表达式的操作类型的不同选择不同的求导过程. 由于数字和符
   号并非一种操作, 所以无法将 ~number?~ 和 ~same-variable?~ 也加入数据导向分派中.
2. 针对和式和积式的求导过程实现如下:
   #+Name: deriv1.scm
   #+BEGIN_SRC scheme
     (define (install-deriv-package)
       (define (deriv-sum exp var)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
       (define (deriv-product exp var)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp)))))

     (put 'deriv-sum '(+) deriv-sum)
     (put 'deriv-product '(*) deriv-product)
   #+END_SRC
3. TODO 添加其他操作的求导程过
4. 求导系统不是以求导实现方式分类, 而是按操作实现方式来分类.

* Exercise2.74
通过为每个操作定义针对不同分支机构的特定版本, 然后将这些操作注册到一个统一的表
中, 然后实现一个过程可以从该表中根据不同的分支机构选择恰当的实现来执行操作.
1. ~get-recode~ 过程
   #+Name: get-recode.scm
   #+BEGIN_SRC scheme
     (define (get-record file)
       ((get 'get-record (institute file)) file))
   #+END_SRC
   各个独立机构的文件应该提供其机构的唯一标识.
2. ~get-salary~ 过程
   #+Name: get-salary.scm
   #+BEGIN_SRC scheme
     (define (get-salary file employee)
       ((get 'get-salary (insitute file)) file employee))
   #+END_SRC
3. ~find-employee-record~ 过程
   #+Name: find-employee-record.scm
   #+BEGIN_SRC scheme
     (define (find-employee-record employee-name file-list)
       (if (null? file-list)
           '()
           (cons ((get 'find-employee-record (institute (car file-list)))
                  employee-name (car file-list))
                 (find-employee-record (cdr file-list)))))
   #+END_SRC
4. 要将新的人事文件结合到系统, 要将这些文件标记特定的机构标识, 还要实现现有操作
   相应与该机构的特定版本.

* Exercise2.75
使用消息传递的方式实现 ~make-from-mag-ang~ 过程如下:
#+Name: make-from-mag-ang.scm
#+BEGIN_SRC scheme
  (define (make-from-mag-ang m a)
    (define (dispatch op)
      (cond ((eq? op 'real-part)
             (* m (cos a)))
            ((eq? op 'imag-part)
             (* m (sin a)))
            ((eq? op 'magnitude) m)
            ((eq? op 'angle) a)
            (else
             (error "Unknow op -- MAKE-FROM-REAL-IMAG" op))))
    dispatch)
#+END_SRC

* Exercise2.76
1. 显式分派风格
   不管是加入新类型还是新操作, 都需要修改原来的通用过程;
2. 数据导向风格
   加入新类型或新操作不需要改变原有的程序, 只需要将对应的新操作加入表中;
3. 消息传递风格
   加入新类型不需要修改原有代码, 但加入新操作需要.

消息传递风格最是个需要经常加入新类型的系统, 数据导向风格的组织方式最适合需要经常
加入新操作的系统.

* Exercise2.77
表达式 ~(magnitude z)~ 的求值过程展开如下:
#+Name: Solutions
#+BEGIN_SRC scheme
  (magnitude x)
  (apply-generic 'magnitude (contents x))
  ((get 'magnitude '(complex)) (contents x))
  (magnitude (contents x))
  ((get 'magnitude '(rectangular)) (contents (contents x)))
#+END_SRC
其中 ~apply-generic~ 被调用了两次, 由于两次参数的类型不同, 实际会调用不同的过程.

* Exercise2.78
利用Scheme的内部类型系统来改进原过程:
#+Name: scheme-number-ex.scm
#+BEGIN_SRC scheme
  ;; modify function: type-tag
  (define (type-tag datum)
    (if (pair? datum)
        (car datum)
        (if (number? datum)
            'scheme-number
            (error "Bad tagged datum -- TYPE-TAG" datum))))
  ;; modify function: contents
  (define (contents datum)
    (if (pair? datum)
        (cdr datum)
        (if (number? datum)
            datum
            (error "Bad tagged datum -- CONTENTS" datum))))
  ;; modify function: attach-tag
  (define (attach-tag type-tag contents)
    (if (eq? type-tag 'scheme-number)
        contents
        (cons type-tag contents)))
#+END_SRC

* Exercise2.79
添加如下过程定义到 ~install-scheme-number-package~ 中:
#+Name: Solutions
#+BEGIN_SRC scheme
  (put 'equ? '(scheme-number scheme-number)
       (lambda (x y) (= x y)))
#+END_SRC
添加如下过程定义到 ~install-rational-package~ 中:
#+Name: Solutions
#+BEGIN_SRC scheme
  (define (equ?-rat x y)
    (= (* (numer x) (denom y))
       (* (denom x) (numer y))))

  (put 'equ? '(rational rational)
       (lambda (x y) (equ?-rat x y)))
#+END_SRC
添加如下过程定义到 ~install-complex-package~ 中:
#+Name: Solutions
#+BEGIN_SRC scheme
  (define (equ?-complex z1 z2)
    (and (= (real-part z1) (real-part z2))
         (= (imag-part z1) (imag-part z1)))))

  (put 'equ? '(complex complex)
       (lambda (z1 z2) (equ?-complex z1 z2)))
#+END_SRC

* Exercise2.80
添加如下过程定义到 ~install-scheme-number-package~ 中:
#+Name: Solutions
#+BEGIN_SRC scheme
  (put '=zero? '(scheme-number)
       (lambda (x) (= x 0)))
#+END_SRC
添加如下过程定义到 ~install-rational-package~ 中:
#+Name: Solutions
#+BEGIN_SRC scheme
  (define (=zero?-rat x)
    (= 0 (numer x)))

  (put '=zero? '(rational)
       (lambda (x) (=zero?-rat x)))
#+END_SRC
添加如下过程定义到 ~install-complex-package~ 中:
#+Name: Solutions
#+BEGIN_SRC scheme
  (define (=zero?-complex z)
    (and (= (real-part z) 0)
         (= (imag-part z) 0)))

  (put '=zero? '(complex)
       (lambda (z) (=zero?-complex z)))
#+END_SRC

* Exercise2.81
1. 如果参数类型相同, 而在表格中又找不到相应的操作, 运用该强制过程会使得程序陷入
   无限循环之中, 因为在找不到相应操作的时候程序会运行强制过程, 而运行强制过程之
   后参数类型并没有发生改变, 也就是说依然不可能存在相应的操作, 所以程序会无休止
   的重复这一过程.
2. 如上所述, 当相同类型参数无法找到相应操作时, 该种强制并不能解决问题.
3. 修改 ~apply-generic~ , 使得程序不会试着强制两个相同类型参数的实现如下:
   #+Name: apply-generic.scm
   #+BEGIN_SRC scheme
     (define (apply-generic op . args)
       (let ((type-tags (map type-tag args)))
         (let ((proc (get op type-tags)))
           (if proc
               (apply proc (map contents args))
               (if (and (= (length args) 2)
                        (not (eq? (car type-tags)
                                  (cadr type-tags))))
                   (let ((type1 (car type-tags))
                         (type2 (cadr type-tags))
                         (a1 (car args))
                         (a2 (cadr args)))
                     (let ((t1->t2 (get-coercion type1 type2))
                           (t2->t1 (get-coercion type2 type1)))
                       (cond (t1->t2
                              (apply-generic op (t1->t2 a1) a2))
                             (t2->t1
                              (apply-generic op a1 (t2->t1 a2)))
                             (else
                              (error "No method for these types"
                                     (list op type-tags)))))))
                   (error "No method for these types"
                          (list op type-tags)))))))
   #+END_SRC

* TODO Exercise2.82
* TOVERIFY Exercise2.83
为每个类型添加 ~raise~ 操作的实现如下:
#+Name: raise.scm
#+BEGIN_SRC scheme
  ;; in install-scheme-number-package:
  (define (raise-to-rational  scheme-number)
    (make-rational scheme-number 1))

  ;; in install-rational-package:
  (define (raise-to-real rational)
    rational)

  ;; in install-real-package:
  (define (raise-to-complex real)
    (make-from-real-imag real 0))

  ;; add to table
  (put 'raise '(scheme-number) raise-to-rational)
  (put 'raise '(rational) raise-to-real)
  (put 'raise '(real) raise-to-complex)
#+END_SRC

* Exercise2.84
利用 ~raise~ 操作修改 ~apply-generic~ 过程如下:
#+Name: apply-generic.scm
#+BEGIN_SRC scheme
  (define (apply-generic op . args)
    (let ((type-tags (map tag args)))
      (let ((proc (get op type-tags)))
        (if proc
            (proc (map contents args))
            (if (= (length args) 2)
                (let ((type1 (car type-tags))
                      (type2 (cadr type-tags))
                      (a1 (car args))
                      (a2 (cadr args)))
                  (if (and (is-top-level type1)
                           (is-top-level type2))
                      (error "No method for these types"
                             (list op type-tags))
                      (if (higher-level type1 type2)
                          (apply-generic op type1 (raise type2))
                          (apply-generic op (raise type1) type2))))
                (error "No method for these types"
                       (list op type-tags)))))))
#+END_SRC

* TODO Exercise2.85
过程 ~drop~ 实现如下:
#+Name: drop.scm
#+BEGIN_SRC scheme

#+END_SRC

* TODO Exercise2.86
* Exercise2.87
为多项式定义和安装 ~zero?~ 过程定义如下:
#+Name: =zero?.scm
#+BEGIN_SRC scheme
  (define (=zero?-poly terms)
    (if (empty-termlist? term?)
        #t
        (and (=zero? (coeff (first-term terms)))
             (=zero?-poly (rest-terms terms)))))

  (put '=zero? '(polynomial) =zero?-poly)
#+END_SRC

* Exercise2.88
定义多项式的减法过程如下:
#+Name: sub-terms.scm
#+BEGIN_SRC scheme
  (define (sub-terms L1 L2)
    (add-terms L1 (neg L2)))

  ;; assume other type has defined neg operation
  (define (neg terms)
    (if (empty-termlist? terms)
        (empty-termlist)
        (let ((term (first-term terms)))
          (adjoin-term
           (make-term (order term)
                      (neg (coeff term)))
           (neg (rest-terms terms)))))
  (put 'neg '(polynomial) neg)
#+END_SRC

* Exercise2.89
定义适宜稠密多项式的项表表示的过程如下:
#+Name: rich-poly.scm
#+BEGIN_SRC scheme
  (define (adjoin-term term term-list)
    (cond ((=zero? (coeff term)) term-list)
          ((= (order term) (length term-list))
           (cons (coeff term) term-list))
          (else
           (adjoin-term term (cons 0 term-list)))))
  (define (the-empty-termlist) '())
  (define (first-term term-list)
    (make-term (- (length term-list) 1)
               (car term-list)))
  (define (rest-terms term-list)
    (let ((rest (cdr term-list)))
      (cond ((null? rest) rest)
            ((= 0 (car rest)) (rest-terms rest))
            (else rest))))
  (define (empty-termlist? term-list) (null? term-list))
#+END_SRC

* TODO Exercise2.90
定义一个多项式系统, 使其同时允许两种表示形式, 实现如下:
#+Name: polynomial.scm
#+BEGIN_SRC scheme
#+END_SRC
