#+TITLE: SICP Chapter 2 Notes
#+AUTHOR: Orab

#+STARTUP: content entitiespretty latexpreview
#+OPTIONS: ^:{} toc:nil

* 数据抽象导引
* 层次性数据和闭包性质
* 符号数据
** 引号
** 符号求导
** 集合的表示
#+NAME: 集合的不同实现方式效率比较
| Implementation   | element-of-set? | adjoin-set | intersection-set | union-set |
|------------------+-----------------+------------+------------------+-----------|
| 无序表           | \Theta(n)            | \Theta(n)       | \Theta(n^{2})            | \Theta(n^{2})     |
| 无序表（可重复） | \Theta(N)            | \Theta(1)       | \Theta(N^{2})            | \Theta(N^{2})     |
| 有序表           | \Theta(n)            | \Theta(n)       | \Theta(n)             | \Theta(n)      |
| 二叉树           | \Theta(log(n))       | \Theta(log(n))  | \Theta(n)             | \Theta(n)      |

** Huffman 编码树
* 抽象数据的多重表示
** 复数的表示
中心思想是通过 *类型标志* 和 *数据导向* 的方式开发一个通用型的过程。

** 带标志数据
** 数据导向的程序设计和可加性
   实现通用型操作的一种方式是 =数据导向= 的设计，系统里存在一张公共的表来决定不同类型对象执行制定操作的方式；而另一种实现方式成为 =消息传递= 的设计，在这种实现方式中没有公共的表，由每个对象自己来决定对于一个通用操作应该采取什么样的过程来执行。 =消息传递= 的方式看起来比 =数据导向= 的方式更为简便，但是 =消息传递= 方式的缺点在于只能允许一个参数的通用型操作，对于多参数的操作，由于任何一个参数自身都不足以判断操作的具体方式，所以只能通过 =数据导向= 的方式来实现。
